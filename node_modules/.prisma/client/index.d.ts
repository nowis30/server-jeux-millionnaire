
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model PropertyTemplate
 * 
 */
export type PropertyTemplate = $Result.DefaultSelection<Prisma.$PropertyTemplatePayload>
/**
 * Model PropertyHolding
 * 
 */
export type PropertyHolding = $Result.DefaultSelection<Prisma.$PropertyHoldingPayload>
/**
 * Model RepairEvent
 * 
 */
export type RepairEvent = $Result.DefaultSelection<Prisma.$RepairEventPayload>
/**
 * Model RefinanceLog
 * 
 */
export type RefinanceLog = $Result.DefaultSelection<Prisma.$RefinanceLogPayload>
/**
 * Model Listing
 * 
 */
export type Listing = $Result.DefaultSelection<Prisma.$ListingPayload>
/**
 * Model MarketHolding
 * 
 */
export type MarketHolding = $Result.DefaultSelection<Prisma.$MarketHoldingPayload>
/**
 * Model MarketTick
 * 
 */
export type MarketTick = $Result.DefaultSelection<Prisma.$MarketTickPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Players
 * const players = await prisma.player.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Players
   * const players = await prisma.player.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs>;

  /**
   * `prisma.propertyTemplate`: Exposes CRUD operations for the **PropertyTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyTemplates
    * const propertyTemplates = await prisma.propertyTemplate.findMany()
    * ```
    */
  get propertyTemplate(): Prisma.PropertyTemplateDelegate<ExtArgs>;

  /**
   * `prisma.propertyHolding`: Exposes CRUD operations for the **PropertyHolding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyHoldings
    * const propertyHoldings = await prisma.propertyHolding.findMany()
    * ```
    */
  get propertyHolding(): Prisma.PropertyHoldingDelegate<ExtArgs>;

  /**
   * `prisma.repairEvent`: Exposes CRUD operations for the **RepairEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairEvents
    * const repairEvents = await prisma.repairEvent.findMany()
    * ```
    */
  get repairEvent(): Prisma.RepairEventDelegate<ExtArgs>;

  /**
   * `prisma.refinanceLog`: Exposes CRUD operations for the **RefinanceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefinanceLogs
    * const refinanceLogs = await prisma.refinanceLog.findMany()
    * ```
    */
  get refinanceLog(): Prisma.RefinanceLogDelegate<ExtArgs>;

  /**
   * `prisma.listing`: Exposes CRUD operations for the **Listing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Listings
    * const listings = await prisma.listing.findMany()
    * ```
    */
  get listing(): Prisma.ListingDelegate<ExtArgs>;

  /**
   * `prisma.marketHolding`: Exposes CRUD operations for the **MarketHolding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketHoldings
    * const marketHoldings = await prisma.marketHolding.findMany()
    * ```
    */
  get marketHolding(): Prisma.MarketHoldingDelegate<ExtArgs>;

  /**
   * `prisma.marketTick`: Exposes CRUD operations for the **MarketTick** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketTicks
    * const marketTicks = await prisma.marketTick.findMany()
    * ```
    */
  get marketTick(): Prisma.MarketTickDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Player: 'Player',
    Game: 'Game',
    PropertyTemplate: 'PropertyTemplate',
    PropertyHolding: 'PropertyHolding',
    RepairEvent: 'RepairEvent',
    RefinanceLog: 'RefinanceLog',
    Listing: 'Listing',
    MarketHolding: 'MarketHolding',
    MarketTick: 'MarketTick'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "player" | "game" | "propertyTemplate" | "propertyHolding" | "repairEvent" | "refinanceLog" | "listing" | "marketHolding" | "marketTick"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      PropertyTemplate: {
        payload: Prisma.$PropertyTemplatePayload<ExtArgs>
        fields: Prisma.PropertyTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTemplatePayload>
          }
          findFirst: {
            args: Prisma.PropertyTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTemplatePayload>
          }
          findMany: {
            args: Prisma.PropertyTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTemplatePayload>[]
          }
          create: {
            args: Prisma.PropertyTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTemplatePayload>
          }
          createMany: {
            args: Prisma.PropertyTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTemplatePayload>[]
          }
          delete: {
            args: Prisma.PropertyTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTemplatePayload>
          }
          update: {
            args: Prisma.PropertyTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTemplatePayload>
          }
          deleteMany: {
            args: Prisma.PropertyTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTemplatePayload>
          }
          aggregate: {
            args: Prisma.PropertyTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyTemplate>
          }
          groupBy: {
            args: Prisma.PropertyTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyTemplateCountAggregateOutputType> | number
          }
        }
      }
      PropertyHolding: {
        payload: Prisma.$PropertyHoldingPayload<ExtArgs>
        fields: Prisma.PropertyHoldingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyHoldingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyHoldingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyHoldingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyHoldingPayload>
          }
          findFirst: {
            args: Prisma.PropertyHoldingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyHoldingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyHoldingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyHoldingPayload>
          }
          findMany: {
            args: Prisma.PropertyHoldingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyHoldingPayload>[]
          }
          create: {
            args: Prisma.PropertyHoldingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyHoldingPayload>
          }
          createMany: {
            args: Prisma.PropertyHoldingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyHoldingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyHoldingPayload>[]
          }
          delete: {
            args: Prisma.PropertyHoldingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyHoldingPayload>
          }
          update: {
            args: Prisma.PropertyHoldingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyHoldingPayload>
          }
          deleteMany: {
            args: Prisma.PropertyHoldingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyHoldingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyHoldingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyHoldingPayload>
          }
          aggregate: {
            args: Prisma.PropertyHoldingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyHolding>
          }
          groupBy: {
            args: Prisma.PropertyHoldingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyHoldingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyHoldingCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyHoldingCountAggregateOutputType> | number
          }
        }
      }
      RepairEvent: {
        payload: Prisma.$RepairEventPayload<ExtArgs>
        fields: Prisma.RepairEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepairEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepairEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEventPayload>
          }
          findFirst: {
            args: Prisma.RepairEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepairEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEventPayload>
          }
          findMany: {
            args: Prisma.RepairEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEventPayload>[]
          }
          create: {
            args: Prisma.RepairEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEventPayload>
          }
          createMany: {
            args: Prisma.RepairEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RepairEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEventPayload>[]
          }
          delete: {
            args: Prisma.RepairEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEventPayload>
          }
          update: {
            args: Prisma.RepairEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEventPayload>
          }
          deleteMany: {
            args: Prisma.RepairEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RepairEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RepairEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEventPayload>
          }
          aggregate: {
            args: Prisma.RepairEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepairEvent>
          }
          groupBy: {
            args: Prisma.RepairEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepairEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepairEventCountArgs<ExtArgs>
            result: $Utils.Optional<RepairEventCountAggregateOutputType> | number
          }
        }
      }
      RefinanceLog: {
        payload: Prisma.$RefinanceLogPayload<ExtArgs>
        fields: Prisma.RefinanceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefinanceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefinanceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefinanceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefinanceLogPayload>
          }
          findFirst: {
            args: Prisma.RefinanceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefinanceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefinanceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefinanceLogPayload>
          }
          findMany: {
            args: Prisma.RefinanceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefinanceLogPayload>[]
          }
          create: {
            args: Prisma.RefinanceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefinanceLogPayload>
          }
          createMany: {
            args: Prisma.RefinanceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefinanceLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefinanceLogPayload>[]
          }
          delete: {
            args: Prisma.RefinanceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefinanceLogPayload>
          }
          update: {
            args: Prisma.RefinanceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefinanceLogPayload>
          }
          deleteMany: {
            args: Prisma.RefinanceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefinanceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefinanceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefinanceLogPayload>
          }
          aggregate: {
            args: Prisma.RefinanceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefinanceLog>
          }
          groupBy: {
            args: Prisma.RefinanceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefinanceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefinanceLogCountArgs<ExtArgs>
            result: $Utils.Optional<RefinanceLogCountAggregateOutputType> | number
          }
        }
      }
      Listing: {
        payload: Prisma.$ListingPayload<ExtArgs>
        fields: Prisma.ListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          findFirst: {
            args: Prisma.ListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          findMany: {
            args: Prisma.ListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          create: {
            args: Prisma.ListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          createMany: {
            args: Prisma.ListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          delete: {
            args: Prisma.ListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          update: {
            args: Prisma.ListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          deleteMany: {
            args: Prisma.ListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          aggregate: {
            args: Prisma.ListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListing>
          }
          groupBy: {
            args: Prisma.ListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListingCountArgs<ExtArgs>
            result: $Utils.Optional<ListingCountAggregateOutputType> | number
          }
        }
      }
      MarketHolding: {
        payload: Prisma.$MarketHoldingPayload<ExtArgs>
        fields: Prisma.MarketHoldingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketHoldingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketHoldingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketHoldingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketHoldingPayload>
          }
          findFirst: {
            args: Prisma.MarketHoldingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketHoldingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketHoldingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketHoldingPayload>
          }
          findMany: {
            args: Prisma.MarketHoldingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketHoldingPayload>[]
          }
          create: {
            args: Prisma.MarketHoldingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketHoldingPayload>
          }
          createMany: {
            args: Prisma.MarketHoldingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketHoldingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketHoldingPayload>[]
          }
          delete: {
            args: Prisma.MarketHoldingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketHoldingPayload>
          }
          update: {
            args: Prisma.MarketHoldingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketHoldingPayload>
          }
          deleteMany: {
            args: Prisma.MarketHoldingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketHoldingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketHoldingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketHoldingPayload>
          }
          aggregate: {
            args: Prisma.MarketHoldingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketHolding>
          }
          groupBy: {
            args: Prisma.MarketHoldingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketHoldingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketHoldingCountArgs<ExtArgs>
            result: $Utils.Optional<MarketHoldingCountAggregateOutputType> | number
          }
        }
      }
      MarketTick: {
        payload: Prisma.$MarketTickPayload<ExtArgs>
        fields: Prisma.MarketTickFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketTickFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTickPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketTickFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTickPayload>
          }
          findFirst: {
            args: Prisma.MarketTickFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTickPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketTickFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTickPayload>
          }
          findMany: {
            args: Prisma.MarketTickFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTickPayload>[]
          }
          create: {
            args: Prisma.MarketTickCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTickPayload>
          }
          createMany: {
            args: Prisma.MarketTickCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketTickCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTickPayload>[]
          }
          delete: {
            args: Prisma.MarketTickDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTickPayload>
          }
          update: {
            args: Prisma.MarketTickUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTickPayload>
          }
          deleteMany: {
            args: Prisma.MarketTickDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketTickUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketTickUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTickPayload>
          }
          aggregate: {
            args: Prisma.MarketTickAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketTick>
          }
          groupBy: {
            args: Prisma.MarketTickGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketTickGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketTickCountArgs<ExtArgs>
            result: $Utils.Optional<MarketTickCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PlayerCountOutputType
   */

  export type PlayerCountOutputType = {
    properties: number
    markets: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PlayerCountOutputTypeCountPropertiesArgs
    markets?: boolean | PlayerCountOutputTypeCountMarketsArgs
  }

  // Custom InputTypes
  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyHoldingWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountMarketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketHoldingWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    players: number
    marketTicks: number
    propertyHoldings: number
    listings: number
    marketHoldings: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | GameCountOutputTypeCountPlayersArgs
    marketTicks?: boolean | GameCountOutputTypeCountMarketTicksArgs
    propertyHoldings?: boolean | GameCountOutputTypeCountPropertyHoldingsArgs
    listings?: boolean | GameCountOutputTypeCountListingsArgs
    marketHoldings?: boolean | GameCountOutputTypeCountMarketHoldingsArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountMarketTicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketTickWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountPropertyHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyHoldingWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountMarketHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketHoldingWhereInput
  }


  /**
   * Count Type PropertyTemplateCountOutputType
   */

  export type PropertyTemplateCountOutputType = {
    holdings: number
    listings: number
  }

  export type PropertyTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holdings?: boolean | PropertyTemplateCountOutputTypeCountHoldingsArgs
    listings?: boolean | PropertyTemplateCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes
  /**
   * PropertyTemplateCountOutputType without action
   */
  export type PropertyTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplateCountOutputType
     */
    select?: PropertyTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyTemplateCountOutputType without action
   */
  export type PropertyTemplateCountOutputTypeCountHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyHoldingWhereInput
  }

  /**
   * PropertyTemplateCountOutputType without action
   */
  export type PropertyTemplateCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }


  /**
   * Count Type PropertyHoldingCountOutputType
   */

  export type PropertyHoldingCountOutputType = {
    events: number
    refinanceLogs: number
    listings: number
  }

  export type PropertyHoldingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | PropertyHoldingCountOutputTypeCountEventsArgs
    refinanceLogs?: boolean | PropertyHoldingCountOutputTypeCountRefinanceLogsArgs
    listings?: boolean | PropertyHoldingCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes
  /**
   * PropertyHoldingCountOutputType without action
   */
  export type PropertyHoldingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHoldingCountOutputType
     */
    select?: PropertyHoldingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyHoldingCountOutputType without action
   */
  export type PropertyHoldingCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairEventWhereInput
  }

  /**
   * PropertyHoldingCountOutputType without action
   */
  export type PropertyHoldingCountOutputTypeCountRefinanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefinanceLogWhereInput
  }

  /**
   * PropertyHoldingCountOutputType without action
   */
  export type PropertyHoldingCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    cash: number | null
    netWorth: number | null
  }

  export type PlayerSumAggregateOutputType = {
    cash: number | null
    netWorth: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: string | null
    nickname: string | null
    cash: number | null
    netWorth: number | null
    createdAt: Date | null
    updatedAt: Date | null
    gameId: string | null
    guestId: string | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: string | null
    nickname: string | null
    cash: number | null
    netWorth: number | null
    createdAt: Date | null
    updatedAt: Date | null
    gameId: string | null
    guestId: string | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    nickname: number
    cash: number
    netWorth: number
    createdAt: number
    updatedAt: number
    gameId: number
    guestId: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    cash?: true
    netWorth?: true
  }

  export type PlayerSumAggregateInputType = {
    cash?: true
    netWorth?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    nickname?: true
    cash?: true
    netWorth?: true
    createdAt?: true
    updatedAt?: true
    gameId?: true
    guestId?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    nickname?: true
    cash?: true
    netWorth?: true
    createdAt?: true
    updatedAt?: true
    gameId?: true
    guestId?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    nickname?: true
    cash?: true
    netWorth?: true
    createdAt?: true
    updatedAt?: true
    gameId?: true
    guestId?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: string
    nickname: string
    cash: number
    netWorth: number
    createdAt: Date
    updatedAt: Date
    gameId: string | null
    guestId: string
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    cash?: boolean
    netWorth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameId?: boolean
    guestId?: boolean
    game?: boolean | Player$gameArgs<ExtArgs>
    properties?: boolean | Player$propertiesArgs<ExtArgs>
    markets?: boolean | Player$marketsArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    cash?: boolean
    netWorth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameId?: boolean
    guestId?: boolean
    game?: boolean | Player$gameArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    nickname?: boolean
    cash?: boolean
    netWorth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameId?: boolean
    guestId?: boolean
  }

  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | Player$gameArgs<ExtArgs>
    properties?: boolean | Player$propertiesArgs<ExtArgs>
    markets?: boolean | Player$marketsArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | Player$gameArgs<ExtArgs>
  }

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      game: Prisma.$GamePayload<ExtArgs> | null
      properties: Prisma.$PropertyHoldingPayload<ExtArgs>[]
      markets: Prisma.$MarketHoldingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nickname: string
      cash: number
      netWorth: number
      createdAt: Date
      updatedAt: Date
      gameId: string | null
      guestId: string
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends Player$gameArgs<ExtArgs> = {}>(args?: Subset<T, Player$gameArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    properties<T extends Player$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Player$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findMany"> | Null>
    markets<T extends Player$marketsArgs<ExtArgs> = {}>(args?: Subset<T, Player$marketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */ 
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'String'>
    readonly nickname: FieldRef<"Player", 'String'>
    readonly cash: FieldRef<"Player", 'Float'>
    readonly netWorth: FieldRef<"Player", 'Float'>
    readonly createdAt: FieldRef<"Player", 'DateTime'>
    readonly updatedAt: FieldRef<"Player", 'DateTime'>
    readonly gameId: FieldRef<"Player", 'String'>
    readonly guestId: FieldRef<"Player", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
  }

  /**
   * Player.game
   */
  export type Player$gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
  }

  /**
   * Player.properties
   */
  export type Player$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    where?: PropertyHoldingWhereInput
    orderBy?: PropertyHoldingOrderByWithRelationInput | PropertyHoldingOrderByWithRelationInput[]
    cursor?: PropertyHoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyHoldingScalarFieldEnum | PropertyHoldingScalarFieldEnum[]
  }

  /**
   * Player.markets
   */
  export type Player$marketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    where?: MarketHoldingWhereInput
    orderBy?: MarketHoldingOrderByWithRelationInput | MarketHoldingOrderByWithRelationInput[]
    cursor?: MarketHoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketHoldingScalarFieldEnum | MarketHoldingScalarFieldEnum[]
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    code: string | null
    status: string | null
    createdAt: Date | null
    startedAt: Date | null
    updatedAt: Date | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    code: string | null
    status: string | null
    createdAt: Date | null
    startedAt: Date | null
    updatedAt: Date | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    code: number
    status: number
    createdAt: number
    startedAt: number
    updatedAt: number
    _all: number
  }


  export type GameMinAggregateInputType = {
    id?: true
    code?: true
    status?: true
    createdAt?: true
    startedAt?: true
    updatedAt?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    code?: true
    status?: true
    createdAt?: true
    startedAt?: true
    updatedAt?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    code?: true
    status?: true
    createdAt?: true
    startedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    code: string
    status: string
    createdAt: Date
    startedAt: Date | null
    updatedAt: Date
    _count: GameCountAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    status?: boolean
    createdAt?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    players?: boolean | Game$playersArgs<ExtArgs>
    marketTicks?: boolean | Game$marketTicksArgs<ExtArgs>
    propertyHoldings?: boolean | Game$propertyHoldingsArgs<ExtArgs>
    listings?: boolean | Game$listingsArgs<ExtArgs>
    marketHoldings?: boolean | Game$marketHoldingsArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    status?: boolean
    createdAt?: boolean
    startedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    code?: boolean
    status?: boolean
    createdAt?: boolean
    startedAt?: boolean
    updatedAt?: boolean
  }

  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | Game$playersArgs<ExtArgs>
    marketTicks?: boolean | Game$marketTicksArgs<ExtArgs>
    propertyHoldings?: boolean | Game$propertyHoldingsArgs<ExtArgs>
    listings?: boolean | Game$listingsArgs<ExtArgs>
    marketHoldings?: boolean | Game$marketHoldingsArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      players: Prisma.$PlayerPayload<ExtArgs>[]
      marketTicks: Prisma.$MarketTickPayload<ExtArgs>[]
      propertyHoldings: Prisma.$PropertyHoldingPayload<ExtArgs>[]
      listings: Prisma.$ListingPayload<ExtArgs>[]
      marketHoldings: Prisma.$MarketHoldingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      status: string
      createdAt: Date
      startedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    players<T extends Game$playersArgs<ExtArgs> = {}>(args?: Subset<T, Game$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany"> | Null>
    marketTicks<T extends Game$marketTicksArgs<ExtArgs> = {}>(args?: Subset<T, Game$marketTicksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "findMany"> | Null>
    propertyHoldings<T extends Game$propertyHoldingsArgs<ExtArgs> = {}>(args?: Subset<T, Game$propertyHoldingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findMany"> | Null>
    listings<T extends Game$listingsArgs<ExtArgs> = {}>(args?: Subset<T, Game$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    marketHoldings<T extends Game$marketHoldingsArgs<ExtArgs> = {}>(args?: Subset<T, Game$marketHoldingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */ 
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly code: FieldRef<"Game", 'String'>
    readonly status: FieldRef<"Game", 'String'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
    readonly startedAt: FieldRef<"Game", 'DateTime'>
    readonly updatedAt: FieldRef<"Game", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
  }

  /**
   * Game.players
   */
  export type Game$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Game.marketTicks
   */
  export type Game$marketTicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
    where?: MarketTickWhereInput
    orderBy?: MarketTickOrderByWithRelationInput | MarketTickOrderByWithRelationInput[]
    cursor?: MarketTickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketTickScalarFieldEnum | MarketTickScalarFieldEnum[]
  }

  /**
   * Game.propertyHoldings
   */
  export type Game$propertyHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    where?: PropertyHoldingWhereInput
    orderBy?: PropertyHoldingOrderByWithRelationInput | PropertyHoldingOrderByWithRelationInput[]
    cursor?: PropertyHoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyHoldingScalarFieldEnum | PropertyHoldingScalarFieldEnum[]
  }

  /**
   * Game.listings
   */
  export type Game$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Game.marketHoldings
   */
  export type Game$marketHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    where?: MarketHoldingWhereInput
    orderBy?: MarketHoldingOrderByWithRelationInput | MarketHoldingOrderByWithRelationInput[]
    cursor?: MarketHoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketHoldingScalarFieldEnum | MarketHoldingScalarFieldEnum[]
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model PropertyTemplate
   */

  export type AggregatePropertyTemplate = {
    _count: PropertyTemplateCountAggregateOutputType | null
    _avg: PropertyTemplateAvgAggregateOutputType | null
    _sum: PropertyTemplateSumAggregateOutputType | null
    _min: PropertyTemplateMinAggregateOutputType | null
    _max: PropertyTemplateMaxAggregateOutputType | null
  }

  export type PropertyTemplateAvgAggregateOutputType = {
    price: number | null
    baseRent: number | null
    taxes: number | null
    insurance: number | null
    maintenance: number | null
  }

  export type PropertyTemplateSumAggregateOutputType = {
    price: number | null
    baseRent: number | null
    taxes: number | null
    insurance: number | null
    maintenance: number | null
  }

  export type PropertyTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    city: string | null
    imageUrl: string | null
    price: number | null
    baseRent: number | null
    taxes: number | null
    insurance: number | null
    maintenance: number | null
  }

  export type PropertyTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    city: string | null
    imageUrl: string | null
    price: number | null
    baseRent: number | null
    taxes: number | null
    insurance: number | null
    maintenance: number | null
  }

  export type PropertyTemplateCountAggregateOutputType = {
    id: number
    name: number
    city: number
    imageUrl: number
    price: number
    baseRent: number
    taxes: number
    insurance: number
    maintenance: number
    _all: number
  }


  export type PropertyTemplateAvgAggregateInputType = {
    price?: true
    baseRent?: true
    taxes?: true
    insurance?: true
    maintenance?: true
  }

  export type PropertyTemplateSumAggregateInputType = {
    price?: true
    baseRent?: true
    taxes?: true
    insurance?: true
    maintenance?: true
  }

  export type PropertyTemplateMinAggregateInputType = {
    id?: true
    name?: true
    city?: true
    imageUrl?: true
    price?: true
    baseRent?: true
    taxes?: true
    insurance?: true
    maintenance?: true
  }

  export type PropertyTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    city?: true
    imageUrl?: true
    price?: true
    baseRent?: true
    taxes?: true
    insurance?: true
    maintenance?: true
  }

  export type PropertyTemplateCountAggregateInputType = {
    id?: true
    name?: true
    city?: true
    imageUrl?: true
    price?: true
    baseRent?: true
    taxes?: true
    insurance?: true
    maintenance?: true
    _all?: true
  }

  export type PropertyTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyTemplate to aggregate.
     */
    where?: PropertyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTemplates to fetch.
     */
    orderBy?: PropertyTemplateOrderByWithRelationInput | PropertyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyTemplates
    **/
    _count?: true | PropertyTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyTemplateMaxAggregateInputType
  }

  export type GetPropertyTemplateAggregateType<T extends PropertyTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyTemplate[P]>
      : GetScalarType<T[P], AggregatePropertyTemplate[P]>
  }




  export type PropertyTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyTemplateWhereInput
    orderBy?: PropertyTemplateOrderByWithAggregationInput | PropertyTemplateOrderByWithAggregationInput[]
    by: PropertyTemplateScalarFieldEnum[] | PropertyTemplateScalarFieldEnum
    having?: PropertyTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyTemplateCountAggregateInputType | true
    _avg?: PropertyTemplateAvgAggregateInputType
    _sum?: PropertyTemplateSumAggregateInputType
    _min?: PropertyTemplateMinAggregateInputType
    _max?: PropertyTemplateMaxAggregateInputType
  }

  export type PropertyTemplateGroupByOutputType = {
    id: string
    name: string
    city: string
    imageUrl: string
    price: number
    baseRent: number
    taxes: number
    insurance: number
    maintenance: number
    _count: PropertyTemplateCountAggregateOutputType | null
    _avg: PropertyTemplateAvgAggregateOutputType | null
    _sum: PropertyTemplateSumAggregateOutputType | null
    _min: PropertyTemplateMinAggregateOutputType | null
    _max: PropertyTemplateMaxAggregateOutputType | null
  }

  type GetPropertyTemplateGroupByPayload<T extends PropertyTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyTemplateGroupByOutputType[P]>
        }
      >
    >


  export type PropertyTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
    imageUrl?: boolean
    price?: boolean
    baseRent?: boolean
    taxes?: boolean
    insurance?: boolean
    maintenance?: boolean
    holdings?: boolean | PropertyTemplate$holdingsArgs<ExtArgs>
    listings?: boolean | PropertyTemplate$listingsArgs<ExtArgs>
    _count?: boolean | PropertyTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyTemplate"]>

  export type PropertyTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
    imageUrl?: boolean
    price?: boolean
    baseRent?: boolean
    taxes?: boolean
    insurance?: boolean
    maintenance?: boolean
  }, ExtArgs["result"]["propertyTemplate"]>

  export type PropertyTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    city?: boolean
    imageUrl?: boolean
    price?: boolean
    baseRent?: boolean
    taxes?: boolean
    insurance?: boolean
    maintenance?: boolean
  }

  export type PropertyTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holdings?: boolean | PropertyTemplate$holdingsArgs<ExtArgs>
    listings?: boolean | PropertyTemplate$listingsArgs<ExtArgs>
    _count?: boolean | PropertyTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PropertyTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyTemplate"
    objects: {
      holdings: Prisma.$PropertyHoldingPayload<ExtArgs>[]
      listings: Prisma.$ListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      city: string
      imageUrl: string
      price: number
      baseRent: number
      taxes: number
      insurance: number
      maintenance: number
    }, ExtArgs["result"]["propertyTemplate"]>
    composites: {}
  }

  type PropertyTemplateGetPayload<S extends boolean | null | undefined | PropertyTemplateDefaultArgs> = $Result.GetResult<Prisma.$PropertyTemplatePayload, S>

  type PropertyTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyTemplateCountAggregateInputType | true
    }

  export interface PropertyTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyTemplate'], meta: { name: 'PropertyTemplate' } }
    /**
     * Find zero or one PropertyTemplate that matches the filter.
     * @param {PropertyTemplateFindUniqueArgs} args - Arguments to find a PropertyTemplate
     * @example
     * // Get one PropertyTemplate
     * const propertyTemplate = await prisma.propertyTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyTemplateFindUniqueArgs>(args: SelectSubset<T, PropertyTemplateFindUniqueArgs<ExtArgs>>): Prisma__PropertyTemplateClient<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyTemplateFindUniqueOrThrowArgs} args - Arguments to find a PropertyTemplate
     * @example
     * // Get one PropertyTemplate
     * const propertyTemplate = await prisma.propertyTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyTemplateClient<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTemplateFindFirstArgs} args - Arguments to find a PropertyTemplate
     * @example
     * // Get one PropertyTemplate
     * const propertyTemplate = await prisma.propertyTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyTemplateFindFirstArgs>(args?: SelectSubset<T, PropertyTemplateFindFirstArgs<ExtArgs>>): Prisma__PropertyTemplateClient<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTemplateFindFirstOrThrowArgs} args - Arguments to find a PropertyTemplate
     * @example
     * // Get one PropertyTemplate
     * const propertyTemplate = await prisma.propertyTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyTemplateClient<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyTemplates
     * const propertyTemplates = await prisma.propertyTemplate.findMany()
     * 
     * // Get first 10 PropertyTemplates
     * const propertyTemplates = await prisma.propertyTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyTemplateWithIdOnly = await prisma.propertyTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyTemplateFindManyArgs>(args?: SelectSubset<T, PropertyTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyTemplate.
     * @param {PropertyTemplateCreateArgs} args - Arguments to create a PropertyTemplate.
     * @example
     * // Create one PropertyTemplate
     * const PropertyTemplate = await prisma.propertyTemplate.create({
     *   data: {
     *     // ... data to create a PropertyTemplate
     *   }
     * })
     * 
     */
    create<T extends PropertyTemplateCreateArgs>(args: SelectSubset<T, PropertyTemplateCreateArgs<ExtArgs>>): Prisma__PropertyTemplateClient<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyTemplates.
     * @param {PropertyTemplateCreateManyArgs} args - Arguments to create many PropertyTemplates.
     * @example
     * // Create many PropertyTemplates
     * const propertyTemplate = await prisma.propertyTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyTemplateCreateManyArgs>(args?: SelectSubset<T, PropertyTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyTemplates and returns the data saved in the database.
     * @param {PropertyTemplateCreateManyAndReturnArgs} args - Arguments to create many PropertyTemplates.
     * @example
     * // Create many PropertyTemplates
     * const propertyTemplate = await prisma.propertyTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyTemplates and only return the `id`
     * const propertyTemplateWithIdOnly = await prisma.propertyTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyTemplate.
     * @param {PropertyTemplateDeleteArgs} args - Arguments to delete one PropertyTemplate.
     * @example
     * // Delete one PropertyTemplate
     * const PropertyTemplate = await prisma.propertyTemplate.delete({
     *   where: {
     *     // ... filter to delete one PropertyTemplate
     *   }
     * })
     * 
     */
    delete<T extends PropertyTemplateDeleteArgs>(args: SelectSubset<T, PropertyTemplateDeleteArgs<ExtArgs>>): Prisma__PropertyTemplateClient<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyTemplate.
     * @param {PropertyTemplateUpdateArgs} args - Arguments to update one PropertyTemplate.
     * @example
     * // Update one PropertyTemplate
     * const propertyTemplate = await prisma.propertyTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyTemplateUpdateArgs>(args: SelectSubset<T, PropertyTemplateUpdateArgs<ExtArgs>>): Prisma__PropertyTemplateClient<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyTemplates.
     * @param {PropertyTemplateDeleteManyArgs} args - Arguments to filter PropertyTemplates to delete.
     * @example
     * // Delete a few PropertyTemplates
     * const { count } = await prisma.propertyTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyTemplateDeleteManyArgs>(args?: SelectSubset<T, PropertyTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyTemplates
     * const propertyTemplate = await prisma.propertyTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyTemplateUpdateManyArgs>(args: SelectSubset<T, PropertyTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyTemplate.
     * @param {PropertyTemplateUpsertArgs} args - Arguments to update or create a PropertyTemplate.
     * @example
     * // Update or create a PropertyTemplate
     * const propertyTemplate = await prisma.propertyTemplate.upsert({
     *   create: {
     *     // ... data to create a PropertyTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyTemplate we want to update
     *   }
     * })
     */
    upsert<T extends PropertyTemplateUpsertArgs>(args: SelectSubset<T, PropertyTemplateUpsertArgs<ExtArgs>>): Prisma__PropertyTemplateClient<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTemplateCountArgs} args - Arguments to filter PropertyTemplates to count.
     * @example
     * // Count the number of PropertyTemplates
     * const count = await prisma.propertyTemplate.count({
     *   where: {
     *     // ... the filter for the PropertyTemplates we want to count
     *   }
     * })
    **/
    count<T extends PropertyTemplateCountArgs>(
      args?: Subset<T, PropertyTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyTemplateAggregateArgs>(args: Subset<T, PropertyTemplateAggregateArgs>): Prisma.PrismaPromise<GetPropertyTemplateAggregateType<T>>

    /**
     * Group by PropertyTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyTemplateGroupByArgs['orderBy'] }
        : { orderBy?: PropertyTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyTemplate model
   */
  readonly fields: PropertyTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    holdings<T extends PropertyTemplate$holdingsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyTemplate$holdingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findMany"> | Null>
    listings<T extends PropertyTemplate$listingsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyTemplate$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyTemplate model
   */ 
  interface PropertyTemplateFieldRefs {
    readonly id: FieldRef<"PropertyTemplate", 'String'>
    readonly name: FieldRef<"PropertyTemplate", 'String'>
    readonly city: FieldRef<"PropertyTemplate", 'String'>
    readonly imageUrl: FieldRef<"PropertyTemplate", 'String'>
    readonly price: FieldRef<"PropertyTemplate", 'Float'>
    readonly baseRent: FieldRef<"PropertyTemplate", 'Float'>
    readonly taxes: FieldRef<"PropertyTemplate", 'Float'>
    readonly insurance: FieldRef<"PropertyTemplate", 'Float'>
    readonly maintenance: FieldRef<"PropertyTemplate", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * PropertyTemplate findUnique
   */
  export type PropertyTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTemplate to fetch.
     */
    where: PropertyTemplateWhereUniqueInput
  }

  /**
   * PropertyTemplate findUniqueOrThrow
   */
  export type PropertyTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTemplate to fetch.
     */
    where: PropertyTemplateWhereUniqueInput
  }

  /**
   * PropertyTemplate findFirst
   */
  export type PropertyTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTemplate to fetch.
     */
    where?: PropertyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTemplates to fetch.
     */
    orderBy?: PropertyTemplateOrderByWithRelationInput | PropertyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTemplates.
     */
    cursor?: PropertyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTemplates.
     */
    distinct?: PropertyTemplateScalarFieldEnum | PropertyTemplateScalarFieldEnum[]
  }

  /**
   * PropertyTemplate findFirstOrThrow
   */
  export type PropertyTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTemplate to fetch.
     */
    where?: PropertyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTemplates to fetch.
     */
    orderBy?: PropertyTemplateOrderByWithRelationInput | PropertyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTemplates.
     */
    cursor?: PropertyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTemplates.
     */
    distinct?: PropertyTemplateScalarFieldEnum | PropertyTemplateScalarFieldEnum[]
  }

  /**
   * PropertyTemplate findMany
   */
  export type PropertyTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTemplates to fetch.
     */
    where?: PropertyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTemplates to fetch.
     */
    orderBy?: PropertyTemplateOrderByWithRelationInput | PropertyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyTemplates.
     */
    cursor?: PropertyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTemplates.
     */
    skip?: number
    distinct?: PropertyTemplateScalarFieldEnum | PropertyTemplateScalarFieldEnum[]
  }

  /**
   * PropertyTemplate create
   */
  export type PropertyTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyTemplate.
     */
    data: XOR<PropertyTemplateCreateInput, PropertyTemplateUncheckedCreateInput>
  }

  /**
   * PropertyTemplate createMany
   */
  export type PropertyTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyTemplates.
     */
    data: PropertyTemplateCreateManyInput | PropertyTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyTemplate createManyAndReturn
   */
  export type PropertyTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyTemplates.
     */
    data: PropertyTemplateCreateManyInput | PropertyTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyTemplate update
   */
  export type PropertyTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyTemplate.
     */
    data: XOR<PropertyTemplateUpdateInput, PropertyTemplateUncheckedUpdateInput>
    /**
     * Choose, which PropertyTemplate to update.
     */
    where: PropertyTemplateWhereUniqueInput
  }

  /**
   * PropertyTemplate updateMany
   */
  export type PropertyTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyTemplates.
     */
    data: XOR<PropertyTemplateUpdateManyMutationInput, PropertyTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PropertyTemplates to update
     */
    where?: PropertyTemplateWhereInput
  }

  /**
   * PropertyTemplate upsert
   */
  export type PropertyTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyTemplate to update in case it exists.
     */
    where: PropertyTemplateWhereUniqueInput
    /**
     * In case the PropertyTemplate found by the `where` argument doesn't exist, create a new PropertyTemplate with this data.
     */
    create: XOR<PropertyTemplateCreateInput, PropertyTemplateUncheckedCreateInput>
    /**
     * In case the PropertyTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyTemplateUpdateInput, PropertyTemplateUncheckedUpdateInput>
  }

  /**
   * PropertyTemplate delete
   */
  export type PropertyTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
    /**
     * Filter which PropertyTemplate to delete.
     */
    where: PropertyTemplateWhereUniqueInput
  }

  /**
   * PropertyTemplate deleteMany
   */
  export type PropertyTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyTemplates to delete
     */
    where?: PropertyTemplateWhereInput
  }

  /**
   * PropertyTemplate.holdings
   */
  export type PropertyTemplate$holdingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    where?: PropertyHoldingWhereInput
    orderBy?: PropertyHoldingOrderByWithRelationInput | PropertyHoldingOrderByWithRelationInput[]
    cursor?: PropertyHoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyHoldingScalarFieldEnum | PropertyHoldingScalarFieldEnum[]
  }

  /**
   * PropertyTemplate.listings
   */
  export type PropertyTemplate$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * PropertyTemplate without action
   */
  export type PropertyTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
  }


  /**
   * Model PropertyHolding
   */

  export type AggregatePropertyHolding = {
    _count: PropertyHoldingCountAggregateOutputType | null
    _avg: PropertyHoldingAvgAggregateOutputType | null
    _sum: PropertyHoldingSumAggregateOutputType | null
    _min: PropertyHoldingMinAggregateOutputType | null
    _max: PropertyHoldingMaxAggregateOutputType | null
  }

  export type PropertyHoldingAvgAggregateOutputType = {
    purchasePrice: number | null
    currentValue: number | null
    currentRent: number | null
    mortgageRate: number | null
    mortgageDebt: number | null
    weeklyPayment: number | null
  }

  export type PropertyHoldingSumAggregateOutputType = {
    purchasePrice: number | null
    currentValue: number | null
    currentRent: number | null
    mortgageRate: number | null
    mortgageDebt: number | null
    weeklyPayment: number | null
  }

  export type PropertyHoldingMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    templateId: string | null
    gameId: string | null
    purchasePrice: number | null
    currentValue: number | null
    currentRent: number | null
    mortgageRate: number | null
    mortgageDebt: number | null
    weeklyPayment: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyHoldingMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    templateId: string | null
    gameId: string | null
    purchasePrice: number | null
    currentValue: number | null
    currentRent: number | null
    mortgageRate: number | null
    mortgageDebt: number | null
    weeklyPayment: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyHoldingCountAggregateOutputType = {
    id: number
    playerId: number
    templateId: number
    gameId: number
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate: number
    mortgageDebt: number
    weeklyPayment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyHoldingAvgAggregateInputType = {
    purchasePrice?: true
    currentValue?: true
    currentRent?: true
    mortgageRate?: true
    mortgageDebt?: true
    weeklyPayment?: true
  }

  export type PropertyHoldingSumAggregateInputType = {
    purchasePrice?: true
    currentValue?: true
    currentRent?: true
    mortgageRate?: true
    mortgageDebt?: true
    weeklyPayment?: true
  }

  export type PropertyHoldingMinAggregateInputType = {
    id?: true
    playerId?: true
    templateId?: true
    gameId?: true
    purchasePrice?: true
    currentValue?: true
    currentRent?: true
    mortgageRate?: true
    mortgageDebt?: true
    weeklyPayment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyHoldingMaxAggregateInputType = {
    id?: true
    playerId?: true
    templateId?: true
    gameId?: true
    purchasePrice?: true
    currentValue?: true
    currentRent?: true
    mortgageRate?: true
    mortgageDebt?: true
    weeklyPayment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyHoldingCountAggregateInputType = {
    id?: true
    playerId?: true
    templateId?: true
    gameId?: true
    purchasePrice?: true
    currentValue?: true
    currentRent?: true
    mortgageRate?: true
    mortgageDebt?: true
    weeklyPayment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyHoldingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyHolding to aggregate.
     */
    where?: PropertyHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyHoldings to fetch.
     */
    orderBy?: PropertyHoldingOrderByWithRelationInput | PropertyHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyHoldings
    **/
    _count?: true | PropertyHoldingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyHoldingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyHoldingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyHoldingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyHoldingMaxAggregateInputType
  }

  export type GetPropertyHoldingAggregateType<T extends PropertyHoldingAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyHolding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyHolding[P]>
      : GetScalarType<T[P], AggregatePropertyHolding[P]>
  }




  export type PropertyHoldingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyHoldingWhereInput
    orderBy?: PropertyHoldingOrderByWithAggregationInput | PropertyHoldingOrderByWithAggregationInput[]
    by: PropertyHoldingScalarFieldEnum[] | PropertyHoldingScalarFieldEnum
    having?: PropertyHoldingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyHoldingCountAggregateInputType | true
    _avg?: PropertyHoldingAvgAggregateInputType
    _sum?: PropertyHoldingSumAggregateInputType
    _min?: PropertyHoldingMinAggregateInputType
    _max?: PropertyHoldingMaxAggregateInputType
  }

  export type PropertyHoldingGroupByOutputType = {
    id: string
    playerId: string
    templateId: string
    gameId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate: number
    mortgageDebt: number
    weeklyPayment: number
    createdAt: Date
    updatedAt: Date
    _count: PropertyHoldingCountAggregateOutputType | null
    _avg: PropertyHoldingAvgAggregateOutputType | null
    _sum: PropertyHoldingSumAggregateOutputType | null
    _min: PropertyHoldingMinAggregateOutputType | null
    _max: PropertyHoldingMaxAggregateOutputType | null
  }

  type GetPropertyHoldingGroupByPayload<T extends PropertyHoldingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyHoldingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyHoldingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyHoldingGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyHoldingGroupByOutputType[P]>
        }
      >
    >


  export type PropertyHoldingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    templateId?: boolean
    gameId?: boolean
    purchasePrice?: boolean
    currentValue?: boolean
    currentRent?: boolean
    mortgageRate?: boolean
    mortgageDebt?: boolean
    weeklyPayment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    template?: boolean | PropertyTemplateDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    events?: boolean | PropertyHolding$eventsArgs<ExtArgs>
    refinanceLogs?: boolean | PropertyHolding$refinanceLogsArgs<ExtArgs>
    listings?: boolean | PropertyHolding$listingsArgs<ExtArgs>
    _count?: boolean | PropertyHoldingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyHolding"]>

  export type PropertyHoldingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    templateId?: boolean
    gameId?: boolean
    purchasePrice?: boolean
    currentValue?: boolean
    currentRent?: boolean
    mortgageRate?: boolean
    mortgageDebt?: boolean
    weeklyPayment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    template?: boolean | PropertyTemplateDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyHolding"]>

  export type PropertyHoldingSelectScalar = {
    id?: boolean
    playerId?: boolean
    templateId?: boolean
    gameId?: boolean
    purchasePrice?: boolean
    currentValue?: boolean
    currentRent?: boolean
    mortgageRate?: boolean
    mortgageDebt?: boolean
    weeklyPayment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyHoldingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    template?: boolean | PropertyTemplateDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    events?: boolean | PropertyHolding$eventsArgs<ExtArgs>
    refinanceLogs?: boolean | PropertyHolding$refinanceLogsArgs<ExtArgs>
    listings?: boolean | PropertyHolding$listingsArgs<ExtArgs>
    _count?: boolean | PropertyHoldingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyHoldingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    template?: boolean | PropertyTemplateDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $PropertyHoldingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyHolding"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      template: Prisma.$PropertyTemplatePayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      events: Prisma.$RepairEventPayload<ExtArgs>[]
      refinanceLogs: Prisma.$RefinanceLogPayload<ExtArgs>[]
      listings: Prisma.$ListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      templateId: string
      gameId: string
      purchasePrice: number
      currentValue: number
      currentRent: number
      mortgageRate: number
      mortgageDebt: number
      weeklyPayment: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyHolding"]>
    composites: {}
  }

  type PropertyHoldingGetPayload<S extends boolean | null | undefined | PropertyHoldingDefaultArgs> = $Result.GetResult<Prisma.$PropertyHoldingPayload, S>

  type PropertyHoldingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyHoldingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyHoldingCountAggregateInputType | true
    }

  export interface PropertyHoldingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyHolding'], meta: { name: 'PropertyHolding' } }
    /**
     * Find zero or one PropertyHolding that matches the filter.
     * @param {PropertyHoldingFindUniqueArgs} args - Arguments to find a PropertyHolding
     * @example
     * // Get one PropertyHolding
     * const propertyHolding = await prisma.propertyHolding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyHoldingFindUniqueArgs>(args: SelectSubset<T, PropertyHoldingFindUniqueArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyHolding that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyHoldingFindUniqueOrThrowArgs} args - Arguments to find a PropertyHolding
     * @example
     * // Get one PropertyHolding
     * const propertyHolding = await prisma.propertyHolding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyHoldingFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyHoldingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyHolding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyHoldingFindFirstArgs} args - Arguments to find a PropertyHolding
     * @example
     * // Get one PropertyHolding
     * const propertyHolding = await prisma.propertyHolding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyHoldingFindFirstArgs>(args?: SelectSubset<T, PropertyHoldingFindFirstArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyHolding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyHoldingFindFirstOrThrowArgs} args - Arguments to find a PropertyHolding
     * @example
     * // Get one PropertyHolding
     * const propertyHolding = await prisma.propertyHolding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyHoldingFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyHoldingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyHoldings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyHoldingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyHoldings
     * const propertyHoldings = await prisma.propertyHolding.findMany()
     * 
     * // Get first 10 PropertyHoldings
     * const propertyHoldings = await prisma.propertyHolding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyHoldingWithIdOnly = await prisma.propertyHolding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyHoldingFindManyArgs>(args?: SelectSubset<T, PropertyHoldingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyHolding.
     * @param {PropertyHoldingCreateArgs} args - Arguments to create a PropertyHolding.
     * @example
     * // Create one PropertyHolding
     * const PropertyHolding = await prisma.propertyHolding.create({
     *   data: {
     *     // ... data to create a PropertyHolding
     *   }
     * })
     * 
     */
    create<T extends PropertyHoldingCreateArgs>(args: SelectSubset<T, PropertyHoldingCreateArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyHoldings.
     * @param {PropertyHoldingCreateManyArgs} args - Arguments to create many PropertyHoldings.
     * @example
     * // Create many PropertyHoldings
     * const propertyHolding = await prisma.propertyHolding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyHoldingCreateManyArgs>(args?: SelectSubset<T, PropertyHoldingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyHoldings and returns the data saved in the database.
     * @param {PropertyHoldingCreateManyAndReturnArgs} args - Arguments to create many PropertyHoldings.
     * @example
     * // Create many PropertyHoldings
     * const propertyHolding = await prisma.propertyHolding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyHoldings and only return the `id`
     * const propertyHoldingWithIdOnly = await prisma.propertyHolding.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyHoldingCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyHoldingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyHolding.
     * @param {PropertyHoldingDeleteArgs} args - Arguments to delete one PropertyHolding.
     * @example
     * // Delete one PropertyHolding
     * const PropertyHolding = await prisma.propertyHolding.delete({
     *   where: {
     *     // ... filter to delete one PropertyHolding
     *   }
     * })
     * 
     */
    delete<T extends PropertyHoldingDeleteArgs>(args: SelectSubset<T, PropertyHoldingDeleteArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyHolding.
     * @param {PropertyHoldingUpdateArgs} args - Arguments to update one PropertyHolding.
     * @example
     * // Update one PropertyHolding
     * const propertyHolding = await prisma.propertyHolding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyHoldingUpdateArgs>(args: SelectSubset<T, PropertyHoldingUpdateArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyHoldings.
     * @param {PropertyHoldingDeleteManyArgs} args - Arguments to filter PropertyHoldings to delete.
     * @example
     * // Delete a few PropertyHoldings
     * const { count } = await prisma.propertyHolding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyHoldingDeleteManyArgs>(args?: SelectSubset<T, PropertyHoldingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyHoldingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyHoldings
     * const propertyHolding = await prisma.propertyHolding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyHoldingUpdateManyArgs>(args: SelectSubset<T, PropertyHoldingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyHolding.
     * @param {PropertyHoldingUpsertArgs} args - Arguments to update or create a PropertyHolding.
     * @example
     * // Update or create a PropertyHolding
     * const propertyHolding = await prisma.propertyHolding.upsert({
     *   create: {
     *     // ... data to create a PropertyHolding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyHolding we want to update
     *   }
     * })
     */
    upsert<T extends PropertyHoldingUpsertArgs>(args: SelectSubset<T, PropertyHoldingUpsertArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyHoldingCountArgs} args - Arguments to filter PropertyHoldings to count.
     * @example
     * // Count the number of PropertyHoldings
     * const count = await prisma.propertyHolding.count({
     *   where: {
     *     // ... the filter for the PropertyHoldings we want to count
     *   }
     * })
    **/
    count<T extends PropertyHoldingCountArgs>(
      args?: Subset<T, PropertyHoldingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyHoldingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyHolding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyHoldingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyHoldingAggregateArgs>(args: Subset<T, PropertyHoldingAggregateArgs>): Prisma.PrismaPromise<GetPropertyHoldingAggregateType<T>>

    /**
     * Group by PropertyHolding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyHoldingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyHoldingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyHoldingGroupByArgs['orderBy'] }
        : { orderBy?: PropertyHoldingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyHoldingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyHoldingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyHolding model
   */
  readonly fields: PropertyHoldingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyHolding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyHoldingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    template<T extends PropertyTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyTemplateDefaultArgs<ExtArgs>>): Prisma__PropertyTemplateClient<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    events<T extends PropertyHolding$eventsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyHolding$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "findMany"> | Null>
    refinanceLogs<T extends PropertyHolding$refinanceLogsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyHolding$refinanceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "findMany"> | Null>
    listings<T extends PropertyHolding$listingsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyHolding$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyHolding model
   */ 
  interface PropertyHoldingFieldRefs {
    readonly id: FieldRef<"PropertyHolding", 'String'>
    readonly playerId: FieldRef<"PropertyHolding", 'String'>
    readonly templateId: FieldRef<"PropertyHolding", 'String'>
    readonly gameId: FieldRef<"PropertyHolding", 'String'>
    readonly purchasePrice: FieldRef<"PropertyHolding", 'Float'>
    readonly currentValue: FieldRef<"PropertyHolding", 'Float'>
    readonly currentRent: FieldRef<"PropertyHolding", 'Float'>
    readonly mortgageRate: FieldRef<"PropertyHolding", 'Float'>
    readonly mortgageDebt: FieldRef<"PropertyHolding", 'Float'>
    readonly weeklyPayment: FieldRef<"PropertyHolding", 'Float'>
    readonly createdAt: FieldRef<"PropertyHolding", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyHolding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyHolding findUnique
   */
  export type PropertyHoldingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    /**
     * Filter, which PropertyHolding to fetch.
     */
    where: PropertyHoldingWhereUniqueInput
  }

  /**
   * PropertyHolding findUniqueOrThrow
   */
  export type PropertyHoldingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    /**
     * Filter, which PropertyHolding to fetch.
     */
    where: PropertyHoldingWhereUniqueInput
  }

  /**
   * PropertyHolding findFirst
   */
  export type PropertyHoldingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    /**
     * Filter, which PropertyHolding to fetch.
     */
    where?: PropertyHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyHoldings to fetch.
     */
    orderBy?: PropertyHoldingOrderByWithRelationInput | PropertyHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyHoldings.
     */
    cursor?: PropertyHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyHoldings.
     */
    distinct?: PropertyHoldingScalarFieldEnum | PropertyHoldingScalarFieldEnum[]
  }

  /**
   * PropertyHolding findFirstOrThrow
   */
  export type PropertyHoldingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    /**
     * Filter, which PropertyHolding to fetch.
     */
    where?: PropertyHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyHoldings to fetch.
     */
    orderBy?: PropertyHoldingOrderByWithRelationInput | PropertyHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyHoldings.
     */
    cursor?: PropertyHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyHoldings.
     */
    distinct?: PropertyHoldingScalarFieldEnum | PropertyHoldingScalarFieldEnum[]
  }

  /**
   * PropertyHolding findMany
   */
  export type PropertyHoldingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    /**
     * Filter, which PropertyHoldings to fetch.
     */
    where?: PropertyHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyHoldings to fetch.
     */
    orderBy?: PropertyHoldingOrderByWithRelationInput | PropertyHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyHoldings.
     */
    cursor?: PropertyHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyHoldings.
     */
    skip?: number
    distinct?: PropertyHoldingScalarFieldEnum | PropertyHoldingScalarFieldEnum[]
  }

  /**
   * PropertyHolding create
   */
  export type PropertyHoldingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyHolding.
     */
    data: XOR<PropertyHoldingCreateInput, PropertyHoldingUncheckedCreateInput>
  }

  /**
   * PropertyHolding createMany
   */
  export type PropertyHoldingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyHoldings.
     */
    data: PropertyHoldingCreateManyInput | PropertyHoldingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyHolding createManyAndReturn
   */
  export type PropertyHoldingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyHoldings.
     */
    data: PropertyHoldingCreateManyInput | PropertyHoldingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyHolding update
   */
  export type PropertyHoldingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyHolding.
     */
    data: XOR<PropertyHoldingUpdateInput, PropertyHoldingUncheckedUpdateInput>
    /**
     * Choose, which PropertyHolding to update.
     */
    where: PropertyHoldingWhereUniqueInput
  }

  /**
   * PropertyHolding updateMany
   */
  export type PropertyHoldingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyHoldings.
     */
    data: XOR<PropertyHoldingUpdateManyMutationInput, PropertyHoldingUncheckedUpdateManyInput>
    /**
     * Filter which PropertyHoldings to update
     */
    where?: PropertyHoldingWhereInput
  }

  /**
   * PropertyHolding upsert
   */
  export type PropertyHoldingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyHolding to update in case it exists.
     */
    where: PropertyHoldingWhereUniqueInput
    /**
     * In case the PropertyHolding found by the `where` argument doesn't exist, create a new PropertyHolding with this data.
     */
    create: XOR<PropertyHoldingCreateInput, PropertyHoldingUncheckedCreateInput>
    /**
     * In case the PropertyHolding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyHoldingUpdateInput, PropertyHoldingUncheckedUpdateInput>
  }

  /**
   * PropertyHolding delete
   */
  export type PropertyHoldingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    /**
     * Filter which PropertyHolding to delete.
     */
    where: PropertyHoldingWhereUniqueInput
  }

  /**
   * PropertyHolding deleteMany
   */
  export type PropertyHoldingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyHoldings to delete
     */
    where?: PropertyHoldingWhereInput
  }

  /**
   * PropertyHolding.events
   */
  export type PropertyHolding$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
    where?: RepairEventWhereInput
    orderBy?: RepairEventOrderByWithRelationInput | RepairEventOrderByWithRelationInput[]
    cursor?: RepairEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepairEventScalarFieldEnum | RepairEventScalarFieldEnum[]
  }

  /**
   * PropertyHolding.refinanceLogs
   */
  export type PropertyHolding$refinanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
    where?: RefinanceLogWhereInput
    orderBy?: RefinanceLogOrderByWithRelationInput | RefinanceLogOrderByWithRelationInput[]
    cursor?: RefinanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefinanceLogScalarFieldEnum | RefinanceLogScalarFieldEnum[]
  }

  /**
   * PropertyHolding.listings
   */
  export type PropertyHolding$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * PropertyHolding without action
   */
  export type PropertyHoldingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
  }


  /**
   * Model RepairEvent
   */

  export type AggregateRepairEvent = {
    _count: RepairEventCountAggregateOutputType | null
    _avg: RepairEventAvgAggregateOutputType | null
    _sum: RepairEventSumAggregateOutputType | null
    _min: RepairEventMinAggregateOutputType | null
    _max: RepairEventMaxAggregateOutputType | null
  }

  export type RepairEventAvgAggregateOutputType = {
    cost: number | null
  }

  export type RepairEventSumAggregateOutputType = {
    cost: number | null
  }

  export type RepairEventMinAggregateOutputType = {
    id: string | null
    holdingId: string | null
    type: string | null
    cost: number | null
    impact: string | null
    createdAt: Date | null
  }

  export type RepairEventMaxAggregateOutputType = {
    id: string | null
    holdingId: string | null
    type: string | null
    cost: number | null
    impact: string | null
    createdAt: Date | null
  }

  export type RepairEventCountAggregateOutputType = {
    id: number
    holdingId: number
    type: number
    cost: number
    impact: number
    createdAt: number
    _all: number
  }


  export type RepairEventAvgAggregateInputType = {
    cost?: true
  }

  export type RepairEventSumAggregateInputType = {
    cost?: true
  }

  export type RepairEventMinAggregateInputType = {
    id?: true
    holdingId?: true
    type?: true
    cost?: true
    impact?: true
    createdAt?: true
  }

  export type RepairEventMaxAggregateInputType = {
    id?: true
    holdingId?: true
    type?: true
    cost?: true
    impact?: true
    createdAt?: true
  }

  export type RepairEventCountAggregateInputType = {
    id?: true
    holdingId?: true
    type?: true
    cost?: true
    impact?: true
    createdAt?: true
    _all?: true
  }

  export type RepairEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RepairEvent to aggregate.
     */
    where?: RepairEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairEvents to fetch.
     */
    orderBy?: RepairEventOrderByWithRelationInput | RepairEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairEvents
    **/
    _count?: true | RepairEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairEventMaxAggregateInputType
  }

  export type GetRepairEventAggregateType<T extends RepairEventAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairEvent[P]>
      : GetScalarType<T[P], AggregateRepairEvent[P]>
  }




  export type RepairEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairEventWhereInput
    orderBy?: RepairEventOrderByWithAggregationInput | RepairEventOrderByWithAggregationInput[]
    by: RepairEventScalarFieldEnum[] | RepairEventScalarFieldEnum
    having?: RepairEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairEventCountAggregateInputType | true
    _avg?: RepairEventAvgAggregateInputType
    _sum?: RepairEventSumAggregateInputType
    _min?: RepairEventMinAggregateInputType
    _max?: RepairEventMaxAggregateInputType
  }

  export type RepairEventGroupByOutputType = {
    id: string
    holdingId: string
    type: string
    cost: number
    impact: string
    createdAt: Date
    _count: RepairEventCountAggregateOutputType | null
    _avg: RepairEventAvgAggregateOutputType | null
    _sum: RepairEventSumAggregateOutputType | null
    _min: RepairEventMinAggregateOutputType | null
    _max: RepairEventMaxAggregateOutputType | null
  }

  type GetRepairEventGroupByPayload<T extends RepairEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepairEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairEventGroupByOutputType[P]>
            : GetScalarType<T[P], RepairEventGroupByOutputType[P]>
        }
      >
    >


  export type RepairEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    holdingId?: boolean
    type?: boolean
    cost?: boolean
    impact?: boolean
    createdAt?: boolean
    holding?: boolean | PropertyHoldingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repairEvent"]>

  export type RepairEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    holdingId?: boolean
    type?: boolean
    cost?: boolean
    impact?: boolean
    createdAt?: boolean
    holding?: boolean | PropertyHoldingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repairEvent"]>

  export type RepairEventSelectScalar = {
    id?: boolean
    holdingId?: boolean
    type?: boolean
    cost?: boolean
    impact?: boolean
    createdAt?: boolean
  }

  export type RepairEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holding?: boolean | PropertyHoldingDefaultArgs<ExtArgs>
  }
  export type RepairEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holding?: boolean | PropertyHoldingDefaultArgs<ExtArgs>
  }

  export type $RepairEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RepairEvent"
    objects: {
      holding: Prisma.$PropertyHoldingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      holdingId: string
      type: string
      cost: number
      impact: string
      createdAt: Date
    }, ExtArgs["result"]["repairEvent"]>
    composites: {}
  }

  type RepairEventGetPayload<S extends boolean | null | undefined | RepairEventDefaultArgs> = $Result.GetResult<Prisma.$RepairEventPayload, S>

  type RepairEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RepairEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RepairEventCountAggregateInputType | true
    }

  export interface RepairEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RepairEvent'], meta: { name: 'RepairEvent' } }
    /**
     * Find zero or one RepairEvent that matches the filter.
     * @param {RepairEventFindUniqueArgs} args - Arguments to find a RepairEvent
     * @example
     * // Get one RepairEvent
     * const repairEvent = await prisma.repairEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RepairEventFindUniqueArgs>(args: SelectSubset<T, RepairEventFindUniqueArgs<ExtArgs>>): Prisma__RepairEventClient<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RepairEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RepairEventFindUniqueOrThrowArgs} args - Arguments to find a RepairEvent
     * @example
     * // Get one RepairEvent
     * const repairEvent = await prisma.repairEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RepairEventFindUniqueOrThrowArgs>(args: SelectSubset<T, RepairEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RepairEventClient<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RepairEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEventFindFirstArgs} args - Arguments to find a RepairEvent
     * @example
     * // Get one RepairEvent
     * const repairEvent = await prisma.repairEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RepairEventFindFirstArgs>(args?: SelectSubset<T, RepairEventFindFirstArgs<ExtArgs>>): Prisma__RepairEventClient<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RepairEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEventFindFirstOrThrowArgs} args - Arguments to find a RepairEvent
     * @example
     * // Get one RepairEvent
     * const repairEvent = await prisma.repairEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RepairEventFindFirstOrThrowArgs>(args?: SelectSubset<T, RepairEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__RepairEventClient<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RepairEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairEvents
     * const repairEvents = await prisma.repairEvent.findMany()
     * 
     * // Get first 10 RepairEvents
     * const repairEvents = await prisma.repairEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairEventWithIdOnly = await prisma.repairEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RepairEventFindManyArgs>(args?: SelectSubset<T, RepairEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RepairEvent.
     * @param {RepairEventCreateArgs} args - Arguments to create a RepairEvent.
     * @example
     * // Create one RepairEvent
     * const RepairEvent = await prisma.repairEvent.create({
     *   data: {
     *     // ... data to create a RepairEvent
     *   }
     * })
     * 
     */
    create<T extends RepairEventCreateArgs>(args: SelectSubset<T, RepairEventCreateArgs<ExtArgs>>): Prisma__RepairEventClient<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RepairEvents.
     * @param {RepairEventCreateManyArgs} args - Arguments to create many RepairEvents.
     * @example
     * // Create many RepairEvents
     * const repairEvent = await prisma.repairEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RepairEventCreateManyArgs>(args?: SelectSubset<T, RepairEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RepairEvents and returns the data saved in the database.
     * @param {RepairEventCreateManyAndReturnArgs} args - Arguments to create many RepairEvents.
     * @example
     * // Create many RepairEvents
     * const repairEvent = await prisma.repairEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RepairEvents and only return the `id`
     * const repairEventWithIdOnly = await prisma.repairEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RepairEventCreateManyAndReturnArgs>(args?: SelectSubset<T, RepairEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RepairEvent.
     * @param {RepairEventDeleteArgs} args - Arguments to delete one RepairEvent.
     * @example
     * // Delete one RepairEvent
     * const RepairEvent = await prisma.repairEvent.delete({
     *   where: {
     *     // ... filter to delete one RepairEvent
     *   }
     * })
     * 
     */
    delete<T extends RepairEventDeleteArgs>(args: SelectSubset<T, RepairEventDeleteArgs<ExtArgs>>): Prisma__RepairEventClient<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RepairEvent.
     * @param {RepairEventUpdateArgs} args - Arguments to update one RepairEvent.
     * @example
     * // Update one RepairEvent
     * const repairEvent = await prisma.repairEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RepairEventUpdateArgs>(args: SelectSubset<T, RepairEventUpdateArgs<ExtArgs>>): Prisma__RepairEventClient<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RepairEvents.
     * @param {RepairEventDeleteManyArgs} args - Arguments to filter RepairEvents to delete.
     * @example
     * // Delete a few RepairEvents
     * const { count } = await prisma.repairEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RepairEventDeleteManyArgs>(args?: SelectSubset<T, RepairEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairEvents
     * const repairEvent = await prisma.repairEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RepairEventUpdateManyArgs>(args: SelectSubset<T, RepairEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairEvent.
     * @param {RepairEventUpsertArgs} args - Arguments to update or create a RepairEvent.
     * @example
     * // Update or create a RepairEvent
     * const repairEvent = await prisma.repairEvent.upsert({
     *   create: {
     *     // ... data to create a RepairEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairEvent we want to update
     *   }
     * })
     */
    upsert<T extends RepairEventUpsertArgs>(args: SelectSubset<T, RepairEventUpsertArgs<ExtArgs>>): Prisma__RepairEventClient<$Result.GetResult<Prisma.$RepairEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RepairEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEventCountArgs} args - Arguments to filter RepairEvents to count.
     * @example
     * // Count the number of RepairEvents
     * const count = await prisma.repairEvent.count({
     *   where: {
     *     // ... the filter for the RepairEvents we want to count
     *   }
     * })
    **/
    count<T extends RepairEventCountArgs>(
      args?: Subset<T, RepairEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairEventAggregateArgs>(args: Subset<T, RepairEventAggregateArgs>): Prisma.PrismaPromise<GetRepairEventAggregateType<T>>

    /**
     * Group by RepairEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairEventGroupByArgs['orderBy'] }
        : { orderBy?: RepairEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RepairEvent model
   */
  readonly fields: RepairEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepairEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    holding<T extends PropertyHoldingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyHoldingDefaultArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RepairEvent model
   */ 
  interface RepairEventFieldRefs {
    readonly id: FieldRef<"RepairEvent", 'String'>
    readonly holdingId: FieldRef<"RepairEvent", 'String'>
    readonly type: FieldRef<"RepairEvent", 'String'>
    readonly cost: FieldRef<"RepairEvent", 'Float'>
    readonly impact: FieldRef<"RepairEvent", 'String'>
    readonly createdAt: FieldRef<"RepairEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RepairEvent findUnique
   */
  export type RepairEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
    /**
     * Filter, which RepairEvent to fetch.
     */
    where: RepairEventWhereUniqueInput
  }

  /**
   * RepairEvent findUniqueOrThrow
   */
  export type RepairEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
    /**
     * Filter, which RepairEvent to fetch.
     */
    where: RepairEventWhereUniqueInput
  }

  /**
   * RepairEvent findFirst
   */
  export type RepairEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
    /**
     * Filter, which RepairEvent to fetch.
     */
    where?: RepairEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairEvents to fetch.
     */
    orderBy?: RepairEventOrderByWithRelationInput | RepairEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairEvents.
     */
    cursor?: RepairEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairEvents.
     */
    distinct?: RepairEventScalarFieldEnum | RepairEventScalarFieldEnum[]
  }

  /**
   * RepairEvent findFirstOrThrow
   */
  export type RepairEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
    /**
     * Filter, which RepairEvent to fetch.
     */
    where?: RepairEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairEvents to fetch.
     */
    orderBy?: RepairEventOrderByWithRelationInput | RepairEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairEvents.
     */
    cursor?: RepairEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairEvents.
     */
    distinct?: RepairEventScalarFieldEnum | RepairEventScalarFieldEnum[]
  }

  /**
   * RepairEvent findMany
   */
  export type RepairEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
    /**
     * Filter, which RepairEvents to fetch.
     */
    where?: RepairEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairEvents to fetch.
     */
    orderBy?: RepairEventOrderByWithRelationInput | RepairEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairEvents.
     */
    cursor?: RepairEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairEvents.
     */
    skip?: number
    distinct?: RepairEventScalarFieldEnum | RepairEventScalarFieldEnum[]
  }

  /**
   * RepairEvent create
   */
  export type RepairEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
    /**
     * The data needed to create a RepairEvent.
     */
    data: XOR<RepairEventCreateInput, RepairEventUncheckedCreateInput>
  }

  /**
   * RepairEvent createMany
   */
  export type RepairEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RepairEvents.
     */
    data: RepairEventCreateManyInput | RepairEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RepairEvent createManyAndReturn
   */
  export type RepairEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RepairEvents.
     */
    data: RepairEventCreateManyInput | RepairEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RepairEvent update
   */
  export type RepairEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
    /**
     * The data needed to update a RepairEvent.
     */
    data: XOR<RepairEventUpdateInput, RepairEventUncheckedUpdateInput>
    /**
     * Choose, which RepairEvent to update.
     */
    where: RepairEventWhereUniqueInput
  }

  /**
   * RepairEvent updateMany
   */
  export type RepairEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RepairEvents.
     */
    data: XOR<RepairEventUpdateManyMutationInput, RepairEventUncheckedUpdateManyInput>
    /**
     * Filter which RepairEvents to update
     */
    where?: RepairEventWhereInput
  }

  /**
   * RepairEvent upsert
   */
  export type RepairEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
    /**
     * The filter to search for the RepairEvent to update in case it exists.
     */
    where: RepairEventWhereUniqueInput
    /**
     * In case the RepairEvent found by the `where` argument doesn't exist, create a new RepairEvent with this data.
     */
    create: XOR<RepairEventCreateInput, RepairEventUncheckedCreateInput>
    /**
     * In case the RepairEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairEventUpdateInput, RepairEventUncheckedUpdateInput>
  }

  /**
   * RepairEvent delete
   */
  export type RepairEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
    /**
     * Filter which RepairEvent to delete.
     */
    where: RepairEventWhereUniqueInput
  }

  /**
   * RepairEvent deleteMany
   */
  export type RepairEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RepairEvents to delete
     */
    where?: RepairEventWhereInput
  }

  /**
   * RepairEvent without action
   */
  export type RepairEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEvent
     */
    select?: RepairEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEventInclude<ExtArgs> | null
  }


  /**
   * Model RefinanceLog
   */

  export type AggregateRefinanceLog = {
    _count: RefinanceLogCountAggregateOutputType | null
    _avg: RefinanceLogAvgAggregateOutputType | null
    _sum: RefinanceLogSumAggregateOutputType | null
    _min: RefinanceLogMinAggregateOutputType | null
    _max: RefinanceLogMaxAggregateOutputType | null
  }

  export type RefinanceLogAvgAggregateOutputType = {
    amount: number | null
    rate: number | null
  }

  export type RefinanceLogSumAggregateOutputType = {
    amount: number | null
    rate: number | null
  }

  export type RefinanceLogMinAggregateOutputType = {
    id: string | null
    holdingId: string | null
    amount: number | null
    rate: number | null
    at: Date | null
  }

  export type RefinanceLogMaxAggregateOutputType = {
    id: string | null
    holdingId: string | null
    amount: number | null
    rate: number | null
    at: Date | null
  }

  export type RefinanceLogCountAggregateOutputType = {
    id: number
    holdingId: number
    amount: number
    rate: number
    at: number
    _all: number
  }


  export type RefinanceLogAvgAggregateInputType = {
    amount?: true
    rate?: true
  }

  export type RefinanceLogSumAggregateInputType = {
    amount?: true
    rate?: true
  }

  export type RefinanceLogMinAggregateInputType = {
    id?: true
    holdingId?: true
    amount?: true
    rate?: true
    at?: true
  }

  export type RefinanceLogMaxAggregateInputType = {
    id?: true
    holdingId?: true
    amount?: true
    rate?: true
    at?: true
  }

  export type RefinanceLogCountAggregateInputType = {
    id?: true
    holdingId?: true
    amount?: true
    rate?: true
    at?: true
    _all?: true
  }

  export type RefinanceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefinanceLog to aggregate.
     */
    where?: RefinanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefinanceLogs to fetch.
     */
    orderBy?: RefinanceLogOrderByWithRelationInput | RefinanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefinanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefinanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefinanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefinanceLogs
    **/
    _count?: true | RefinanceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefinanceLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefinanceLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefinanceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefinanceLogMaxAggregateInputType
  }

  export type GetRefinanceLogAggregateType<T extends RefinanceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateRefinanceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefinanceLog[P]>
      : GetScalarType<T[P], AggregateRefinanceLog[P]>
  }




  export type RefinanceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefinanceLogWhereInput
    orderBy?: RefinanceLogOrderByWithAggregationInput | RefinanceLogOrderByWithAggregationInput[]
    by: RefinanceLogScalarFieldEnum[] | RefinanceLogScalarFieldEnum
    having?: RefinanceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefinanceLogCountAggregateInputType | true
    _avg?: RefinanceLogAvgAggregateInputType
    _sum?: RefinanceLogSumAggregateInputType
    _min?: RefinanceLogMinAggregateInputType
    _max?: RefinanceLogMaxAggregateInputType
  }

  export type RefinanceLogGroupByOutputType = {
    id: string
    holdingId: string
    amount: number
    rate: number
    at: Date
    _count: RefinanceLogCountAggregateOutputType | null
    _avg: RefinanceLogAvgAggregateOutputType | null
    _sum: RefinanceLogSumAggregateOutputType | null
    _min: RefinanceLogMinAggregateOutputType | null
    _max: RefinanceLogMaxAggregateOutputType | null
  }

  type GetRefinanceLogGroupByPayload<T extends RefinanceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefinanceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefinanceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefinanceLogGroupByOutputType[P]>
            : GetScalarType<T[P], RefinanceLogGroupByOutputType[P]>
        }
      >
    >


  export type RefinanceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    holdingId?: boolean
    amount?: boolean
    rate?: boolean
    at?: boolean
    holding?: boolean | PropertyHoldingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refinanceLog"]>

  export type RefinanceLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    holdingId?: boolean
    amount?: boolean
    rate?: boolean
    at?: boolean
    holding?: boolean | PropertyHoldingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refinanceLog"]>

  export type RefinanceLogSelectScalar = {
    id?: boolean
    holdingId?: boolean
    amount?: boolean
    rate?: boolean
    at?: boolean
  }

  export type RefinanceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holding?: boolean | PropertyHoldingDefaultArgs<ExtArgs>
  }
  export type RefinanceLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holding?: boolean | PropertyHoldingDefaultArgs<ExtArgs>
  }

  export type $RefinanceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefinanceLog"
    objects: {
      holding: Prisma.$PropertyHoldingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      holdingId: string
      amount: number
      rate: number
      at: Date
    }, ExtArgs["result"]["refinanceLog"]>
    composites: {}
  }

  type RefinanceLogGetPayload<S extends boolean | null | undefined | RefinanceLogDefaultArgs> = $Result.GetResult<Prisma.$RefinanceLogPayload, S>

  type RefinanceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefinanceLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefinanceLogCountAggregateInputType | true
    }

  export interface RefinanceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefinanceLog'], meta: { name: 'RefinanceLog' } }
    /**
     * Find zero or one RefinanceLog that matches the filter.
     * @param {RefinanceLogFindUniqueArgs} args - Arguments to find a RefinanceLog
     * @example
     * // Get one RefinanceLog
     * const refinanceLog = await prisma.refinanceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefinanceLogFindUniqueArgs>(args: SelectSubset<T, RefinanceLogFindUniqueArgs<ExtArgs>>): Prisma__RefinanceLogClient<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefinanceLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefinanceLogFindUniqueOrThrowArgs} args - Arguments to find a RefinanceLog
     * @example
     * // Get one RefinanceLog
     * const refinanceLog = await prisma.refinanceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefinanceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, RefinanceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefinanceLogClient<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefinanceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefinanceLogFindFirstArgs} args - Arguments to find a RefinanceLog
     * @example
     * // Get one RefinanceLog
     * const refinanceLog = await prisma.refinanceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefinanceLogFindFirstArgs>(args?: SelectSubset<T, RefinanceLogFindFirstArgs<ExtArgs>>): Prisma__RefinanceLogClient<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefinanceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefinanceLogFindFirstOrThrowArgs} args - Arguments to find a RefinanceLog
     * @example
     * // Get one RefinanceLog
     * const refinanceLog = await prisma.refinanceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefinanceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, RefinanceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefinanceLogClient<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefinanceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefinanceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefinanceLogs
     * const refinanceLogs = await prisma.refinanceLog.findMany()
     * 
     * // Get first 10 RefinanceLogs
     * const refinanceLogs = await prisma.refinanceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refinanceLogWithIdOnly = await prisma.refinanceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefinanceLogFindManyArgs>(args?: SelectSubset<T, RefinanceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefinanceLog.
     * @param {RefinanceLogCreateArgs} args - Arguments to create a RefinanceLog.
     * @example
     * // Create one RefinanceLog
     * const RefinanceLog = await prisma.refinanceLog.create({
     *   data: {
     *     // ... data to create a RefinanceLog
     *   }
     * })
     * 
     */
    create<T extends RefinanceLogCreateArgs>(args: SelectSubset<T, RefinanceLogCreateArgs<ExtArgs>>): Prisma__RefinanceLogClient<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefinanceLogs.
     * @param {RefinanceLogCreateManyArgs} args - Arguments to create many RefinanceLogs.
     * @example
     * // Create many RefinanceLogs
     * const refinanceLog = await prisma.refinanceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefinanceLogCreateManyArgs>(args?: SelectSubset<T, RefinanceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefinanceLogs and returns the data saved in the database.
     * @param {RefinanceLogCreateManyAndReturnArgs} args - Arguments to create many RefinanceLogs.
     * @example
     * // Create many RefinanceLogs
     * const refinanceLog = await prisma.refinanceLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefinanceLogs and only return the `id`
     * const refinanceLogWithIdOnly = await prisma.refinanceLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefinanceLogCreateManyAndReturnArgs>(args?: SelectSubset<T, RefinanceLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefinanceLog.
     * @param {RefinanceLogDeleteArgs} args - Arguments to delete one RefinanceLog.
     * @example
     * // Delete one RefinanceLog
     * const RefinanceLog = await prisma.refinanceLog.delete({
     *   where: {
     *     // ... filter to delete one RefinanceLog
     *   }
     * })
     * 
     */
    delete<T extends RefinanceLogDeleteArgs>(args: SelectSubset<T, RefinanceLogDeleteArgs<ExtArgs>>): Prisma__RefinanceLogClient<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefinanceLog.
     * @param {RefinanceLogUpdateArgs} args - Arguments to update one RefinanceLog.
     * @example
     * // Update one RefinanceLog
     * const refinanceLog = await prisma.refinanceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefinanceLogUpdateArgs>(args: SelectSubset<T, RefinanceLogUpdateArgs<ExtArgs>>): Prisma__RefinanceLogClient<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefinanceLogs.
     * @param {RefinanceLogDeleteManyArgs} args - Arguments to filter RefinanceLogs to delete.
     * @example
     * // Delete a few RefinanceLogs
     * const { count } = await prisma.refinanceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefinanceLogDeleteManyArgs>(args?: SelectSubset<T, RefinanceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefinanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefinanceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefinanceLogs
     * const refinanceLog = await prisma.refinanceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefinanceLogUpdateManyArgs>(args: SelectSubset<T, RefinanceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefinanceLog.
     * @param {RefinanceLogUpsertArgs} args - Arguments to update or create a RefinanceLog.
     * @example
     * // Update or create a RefinanceLog
     * const refinanceLog = await prisma.refinanceLog.upsert({
     *   create: {
     *     // ... data to create a RefinanceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefinanceLog we want to update
     *   }
     * })
     */
    upsert<T extends RefinanceLogUpsertArgs>(args: SelectSubset<T, RefinanceLogUpsertArgs<ExtArgs>>): Prisma__RefinanceLogClient<$Result.GetResult<Prisma.$RefinanceLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefinanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefinanceLogCountArgs} args - Arguments to filter RefinanceLogs to count.
     * @example
     * // Count the number of RefinanceLogs
     * const count = await prisma.refinanceLog.count({
     *   where: {
     *     // ... the filter for the RefinanceLogs we want to count
     *   }
     * })
    **/
    count<T extends RefinanceLogCountArgs>(
      args?: Subset<T, RefinanceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefinanceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefinanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefinanceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefinanceLogAggregateArgs>(args: Subset<T, RefinanceLogAggregateArgs>): Prisma.PrismaPromise<GetRefinanceLogAggregateType<T>>

    /**
     * Group by RefinanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefinanceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefinanceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefinanceLogGroupByArgs['orderBy'] }
        : { orderBy?: RefinanceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefinanceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefinanceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefinanceLog model
   */
  readonly fields: RefinanceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefinanceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefinanceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    holding<T extends PropertyHoldingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyHoldingDefaultArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefinanceLog model
   */ 
  interface RefinanceLogFieldRefs {
    readonly id: FieldRef<"RefinanceLog", 'String'>
    readonly holdingId: FieldRef<"RefinanceLog", 'String'>
    readonly amount: FieldRef<"RefinanceLog", 'Float'>
    readonly rate: FieldRef<"RefinanceLog", 'Float'>
    readonly at: FieldRef<"RefinanceLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefinanceLog findUnique
   */
  export type RefinanceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
    /**
     * Filter, which RefinanceLog to fetch.
     */
    where: RefinanceLogWhereUniqueInput
  }

  /**
   * RefinanceLog findUniqueOrThrow
   */
  export type RefinanceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
    /**
     * Filter, which RefinanceLog to fetch.
     */
    where: RefinanceLogWhereUniqueInput
  }

  /**
   * RefinanceLog findFirst
   */
  export type RefinanceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
    /**
     * Filter, which RefinanceLog to fetch.
     */
    where?: RefinanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefinanceLogs to fetch.
     */
    orderBy?: RefinanceLogOrderByWithRelationInput | RefinanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefinanceLogs.
     */
    cursor?: RefinanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefinanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefinanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefinanceLogs.
     */
    distinct?: RefinanceLogScalarFieldEnum | RefinanceLogScalarFieldEnum[]
  }

  /**
   * RefinanceLog findFirstOrThrow
   */
  export type RefinanceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
    /**
     * Filter, which RefinanceLog to fetch.
     */
    where?: RefinanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefinanceLogs to fetch.
     */
    orderBy?: RefinanceLogOrderByWithRelationInput | RefinanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefinanceLogs.
     */
    cursor?: RefinanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefinanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefinanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefinanceLogs.
     */
    distinct?: RefinanceLogScalarFieldEnum | RefinanceLogScalarFieldEnum[]
  }

  /**
   * RefinanceLog findMany
   */
  export type RefinanceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
    /**
     * Filter, which RefinanceLogs to fetch.
     */
    where?: RefinanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefinanceLogs to fetch.
     */
    orderBy?: RefinanceLogOrderByWithRelationInput | RefinanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefinanceLogs.
     */
    cursor?: RefinanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefinanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefinanceLogs.
     */
    skip?: number
    distinct?: RefinanceLogScalarFieldEnum | RefinanceLogScalarFieldEnum[]
  }

  /**
   * RefinanceLog create
   */
  export type RefinanceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a RefinanceLog.
     */
    data: XOR<RefinanceLogCreateInput, RefinanceLogUncheckedCreateInput>
  }

  /**
   * RefinanceLog createMany
   */
  export type RefinanceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefinanceLogs.
     */
    data: RefinanceLogCreateManyInput | RefinanceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefinanceLog createManyAndReturn
   */
  export type RefinanceLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefinanceLogs.
     */
    data: RefinanceLogCreateManyInput | RefinanceLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefinanceLog update
   */
  export type RefinanceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a RefinanceLog.
     */
    data: XOR<RefinanceLogUpdateInput, RefinanceLogUncheckedUpdateInput>
    /**
     * Choose, which RefinanceLog to update.
     */
    where: RefinanceLogWhereUniqueInput
  }

  /**
   * RefinanceLog updateMany
   */
  export type RefinanceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefinanceLogs.
     */
    data: XOR<RefinanceLogUpdateManyMutationInput, RefinanceLogUncheckedUpdateManyInput>
    /**
     * Filter which RefinanceLogs to update
     */
    where?: RefinanceLogWhereInput
  }

  /**
   * RefinanceLog upsert
   */
  export type RefinanceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the RefinanceLog to update in case it exists.
     */
    where: RefinanceLogWhereUniqueInput
    /**
     * In case the RefinanceLog found by the `where` argument doesn't exist, create a new RefinanceLog with this data.
     */
    create: XOR<RefinanceLogCreateInput, RefinanceLogUncheckedCreateInput>
    /**
     * In case the RefinanceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefinanceLogUpdateInput, RefinanceLogUncheckedUpdateInput>
  }

  /**
   * RefinanceLog delete
   */
  export type RefinanceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
    /**
     * Filter which RefinanceLog to delete.
     */
    where: RefinanceLogWhereUniqueInput
  }

  /**
   * RefinanceLog deleteMany
   */
  export type RefinanceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefinanceLogs to delete
     */
    where?: RefinanceLogWhereInput
  }

  /**
   * RefinanceLog without action
   */
  export type RefinanceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefinanceLog
     */
    select?: RefinanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefinanceLogInclude<ExtArgs> | null
  }


  /**
   * Model Listing
   */

  export type AggregateListing = {
    _count: ListingCountAggregateOutputType | null
    _avg: ListingAvgAggregateOutputType | null
    _sum: ListingSumAggregateOutputType | null
    _min: ListingMinAggregateOutputType | null
    _max: ListingMaxAggregateOutputType | null
  }

  export type ListingAvgAggregateOutputType = {
    price: number | null
  }

  export type ListingSumAggregateOutputType = {
    price: number | null
  }

  export type ListingMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    holdingId: string | null
    templateId: string | null
    sellerId: string | null
    price: number | null
    type: string | null
    createdAt: Date | null
  }

  export type ListingMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    holdingId: string | null
    templateId: string | null
    sellerId: string | null
    price: number | null
    type: string | null
    createdAt: Date | null
  }

  export type ListingCountAggregateOutputType = {
    id: number
    gameId: number
    holdingId: number
    templateId: number
    sellerId: number
    price: number
    type: number
    createdAt: number
    _all: number
  }


  export type ListingAvgAggregateInputType = {
    price?: true
  }

  export type ListingSumAggregateInputType = {
    price?: true
  }

  export type ListingMinAggregateInputType = {
    id?: true
    gameId?: true
    holdingId?: true
    templateId?: true
    sellerId?: true
    price?: true
    type?: true
    createdAt?: true
  }

  export type ListingMaxAggregateInputType = {
    id?: true
    gameId?: true
    holdingId?: true
    templateId?: true
    sellerId?: true
    price?: true
    type?: true
    createdAt?: true
  }

  export type ListingCountAggregateInputType = {
    id?: true
    gameId?: true
    holdingId?: true
    templateId?: true
    sellerId?: true
    price?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type ListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Listing to aggregate.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Listings
    **/
    _count?: true | ListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListingMaxAggregateInputType
  }

  export type GetListingAggregateType<T extends ListingAggregateArgs> = {
        [P in keyof T & keyof AggregateListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListing[P]>
      : GetScalarType<T[P], AggregateListing[P]>
  }




  export type ListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithAggregationInput | ListingOrderByWithAggregationInput[]
    by: ListingScalarFieldEnum[] | ListingScalarFieldEnum
    having?: ListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListingCountAggregateInputType | true
    _avg?: ListingAvgAggregateInputType
    _sum?: ListingSumAggregateInputType
    _min?: ListingMinAggregateInputType
    _max?: ListingMaxAggregateInputType
  }

  export type ListingGroupByOutputType = {
    id: string
    gameId: string
    holdingId: string | null
    templateId: string | null
    sellerId: string | null
    price: number
    type: string
    createdAt: Date
    _count: ListingCountAggregateOutputType | null
    _avg: ListingAvgAggregateOutputType | null
    _sum: ListingSumAggregateOutputType | null
    _min: ListingMinAggregateOutputType | null
    _max: ListingMaxAggregateOutputType | null
  }

  type GetListingGroupByPayload<T extends ListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListingGroupByOutputType[P]>
            : GetScalarType<T[P], ListingGroupByOutputType[P]>
        }
      >
    >


  export type ListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    holdingId?: boolean
    templateId?: boolean
    sellerId?: boolean
    price?: boolean
    type?: boolean
    createdAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    holding?: boolean | Listing$holdingArgs<ExtArgs>
    template?: boolean | Listing$templateArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    holdingId?: boolean
    templateId?: boolean
    sellerId?: boolean
    price?: boolean
    type?: boolean
    createdAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    holding?: boolean | Listing$holdingArgs<ExtArgs>
    template?: boolean | Listing$templateArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectScalar = {
    id?: boolean
    gameId?: boolean
    holdingId?: boolean
    templateId?: boolean
    sellerId?: boolean
    price?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type ListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    holding?: boolean | Listing$holdingArgs<ExtArgs>
    template?: boolean | Listing$templateArgs<ExtArgs>
  }
  export type ListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    holding?: boolean | Listing$holdingArgs<ExtArgs>
    template?: boolean | Listing$templateArgs<ExtArgs>
  }

  export type $ListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Listing"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      holding: Prisma.$PropertyHoldingPayload<ExtArgs> | null
      template: Prisma.$PropertyTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      holdingId: string | null
      templateId: string | null
      sellerId: string | null
      price: number
      type: string
      createdAt: Date
    }, ExtArgs["result"]["listing"]>
    composites: {}
  }

  type ListingGetPayload<S extends boolean | null | undefined | ListingDefaultArgs> = $Result.GetResult<Prisma.$ListingPayload, S>

  type ListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ListingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ListingCountAggregateInputType | true
    }

  export interface ListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Listing'], meta: { name: 'Listing' } }
    /**
     * Find zero or one Listing that matches the filter.
     * @param {ListingFindUniqueArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListingFindUniqueArgs>(args: SelectSubset<T, ListingFindUniqueArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Listing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ListingFindUniqueOrThrowArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListingFindUniqueOrThrowArgs>(args: SelectSubset<T, ListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Listing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindFirstArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListingFindFirstArgs>(args?: SelectSubset<T, ListingFindFirstArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Listing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindFirstOrThrowArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListingFindFirstOrThrowArgs>(args?: SelectSubset<T, ListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Listings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Listings
     * const listings = await prisma.listing.findMany()
     * 
     * // Get first 10 Listings
     * const listings = await prisma.listing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listingWithIdOnly = await prisma.listing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListingFindManyArgs>(args?: SelectSubset<T, ListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Listing.
     * @param {ListingCreateArgs} args - Arguments to create a Listing.
     * @example
     * // Create one Listing
     * const Listing = await prisma.listing.create({
     *   data: {
     *     // ... data to create a Listing
     *   }
     * })
     * 
     */
    create<T extends ListingCreateArgs>(args: SelectSubset<T, ListingCreateArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Listings.
     * @param {ListingCreateManyArgs} args - Arguments to create many Listings.
     * @example
     * // Create many Listings
     * const listing = await prisma.listing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListingCreateManyArgs>(args?: SelectSubset<T, ListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Listings and returns the data saved in the database.
     * @param {ListingCreateManyAndReturnArgs} args - Arguments to create many Listings.
     * @example
     * // Create many Listings
     * const listing = await prisma.listing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Listings and only return the `id`
     * const listingWithIdOnly = await prisma.listing.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListingCreateManyAndReturnArgs>(args?: SelectSubset<T, ListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Listing.
     * @param {ListingDeleteArgs} args - Arguments to delete one Listing.
     * @example
     * // Delete one Listing
     * const Listing = await prisma.listing.delete({
     *   where: {
     *     // ... filter to delete one Listing
     *   }
     * })
     * 
     */
    delete<T extends ListingDeleteArgs>(args: SelectSubset<T, ListingDeleteArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Listing.
     * @param {ListingUpdateArgs} args - Arguments to update one Listing.
     * @example
     * // Update one Listing
     * const listing = await prisma.listing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListingUpdateArgs>(args: SelectSubset<T, ListingUpdateArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Listings.
     * @param {ListingDeleteManyArgs} args - Arguments to filter Listings to delete.
     * @example
     * // Delete a few Listings
     * const { count } = await prisma.listing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListingDeleteManyArgs>(args?: SelectSubset<T, ListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Listings
     * const listing = await prisma.listing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListingUpdateManyArgs>(args: SelectSubset<T, ListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Listing.
     * @param {ListingUpsertArgs} args - Arguments to update or create a Listing.
     * @example
     * // Update or create a Listing
     * const listing = await prisma.listing.upsert({
     *   create: {
     *     // ... data to create a Listing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Listing we want to update
     *   }
     * })
     */
    upsert<T extends ListingUpsertArgs>(args: SelectSubset<T, ListingUpsertArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Listings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingCountArgs} args - Arguments to filter Listings to count.
     * @example
     * // Count the number of Listings
     * const count = await prisma.listing.count({
     *   where: {
     *     // ... the filter for the Listings we want to count
     *   }
     * })
    **/
    count<T extends ListingCountArgs>(
      args?: Subset<T, ListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Listing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListingAggregateArgs>(args: Subset<T, ListingAggregateArgs>): Prisma.PrismaPromise<GetListingAggregateType<T>>

    /**
     * Group by Listing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListingGroupByArgs['orderBy'] }
        : { orderBy?: ListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Listing model
   */
  readonly fields: ListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Listing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    holding<T extends Listing$holdingArgs<ExtArgs> = {}>(args?: Subset<T, Listing$holdingArgs<ExtArgs>>): Prisma__PropertyHoldingClient<$Result.GetResult<Prisma.$PropertyHoldingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    template<T extends Listing$templateArgs<ExtArgs> = {}>(args?: Subset<T, Listing$templateArgs<ExtArgs>>): Prisma__PropertyTemplateClient<$Result.GetResult<Prisma.$PropertyTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Listing model
   */ 
  interface ListingFieldRefs {
    readonly id: FieldRef<"Listing", 'String'>
    readonly gameId: FieldRef<"Listing", 'String'>
    readonly holdingId: FieldRef<"Listing", 'String'>
    readonly templateId: FieldRef<"Listing", 'String'>
    readonly sellerId: FieldRef<"Listing", 'String'>
    readonly price: FieldRef<"Listing", 'Float'>
    readonly type: FieldRef<"Listing", 'String'>
    readonly createdAt: FieldRef<"Listing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Listing findUnique
   */
  export type ListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing findUniqueOrThrow
   */
  export type ListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing findFirst
   */
  export type ListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Listings.
     */
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing findFirstOrThrow
   */
  export type ListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Listings.
     */
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing findMany
   */
  export type ListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listings to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing create
   */
  export type ListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The data needed to create a Listing.
     */
    data: XOR<ListingCreateInput, ListingUncheckedCreateInput>
  }

  /**
   * Listing createMany
   */
  export type ListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Listings.
     */
    data: ListingCreateManyInput | ListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Listing createManyAndReturn
   */
  export type ListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Listings.
     */
    data: ListingCreateManyInput | ListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Listing update
   */
  export type ListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The data needed to update a Listing.
     */
    data: XOR<ListingUpdateInput, ListingUncheckedUpdateInput>
    /**
     * Choose, which Listing to update.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing updateMany
   */
  export type ListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Listings.
     */
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyInput>
    /**
     * Filter which Listings to update
     */
    where?: ListingWhereInput
  }

  /**
   * Listing upsert
   */
  export type ListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The filter to search for the Listing to update in case it exists.
     */
    where: ListingWhereUniqueInput
    /**
     * In case the Listing found by the `where` argument doesn't exist, create a new Listing with this data.
     */
    create: XOR<ListingCreateInput, ListingUncheckedCreateInput>
    /**
     * In case the Listing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListingUpdateInput, ListingUncheckedUpdateInput>
  }

  /**
   * Listing delete
   */
  export type ListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter which Listing to delete.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing deleteMany
   */
  export type ListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Listings to delete
     */
    where?: ListingWhereInput
  }

  /**
   * Listing.holding
   */
  export type Listing$holdingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyHolding
     */
    select?: PropertyHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyHoldingInclude<ExtArgs> | null
    where?: PropertyHoldingWhereInput
  }

  /**
   * Listing.template
   */
  export type Listing$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTemplate
     */
    select?: PropertyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTemplateInclude<ExtArgs> | null
    where?: PropertyTemplateWhereInput
  }

  /**
   * Listing without action
   */
  export type ListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
  }


  /**
   * Model MarketHolding
   */

  export type AggregateMarketHolding = {
    _count: MarketHoldingCountAggregateOutputType | null
    _avg: MarketHoldingAvgAggregateOutputType | null
    _sum: MarketHoldingSumAggregateOutputType | null
    _min: MarketHoldingMinAggregateOutputType | null
    _max: MarketHoldingMaxAggregateOutputType | null
  }

  export type MarketHoldingAvgAggregateOutputType = {
    quantity: number | null
    avgPrice: number | null
  }

  export type MarketHoldingSumAggregateOutputType = {
    quantity: number | null
    avgPrice: number | null
  }

  export type MarketHoldingMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    gameId: string | null
    symbol: string | null
    quantity: number | null
    avgPrice: number | null
  }

  export type MarketHoldingMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    gameId: string | null
    symbol: string | null
    quantity: number | null
    avgPrice: number | null
  }

  export type MarketHoldingCountAggregateOutputType = {
    id: number
    playerId: number
    gameId: number
    symbol: number
    quantity: number
    avgPrice: number
    _all: number
  }


  export type MarketHoldingAvgAggregateInputType = {
    quantity?: true
    avgPrice?: true
  }

  export type MarketHoldingSumAggregateInputType = {
    quantity?: true
    avgPrice?: true
  }

  export type MarketHoldingMinAggregateInputType = {
    id?: true
    playerId?: true
    gameId?: true
    symbol?: true
    quantity?: true
    avgPrice?: true
  }

  export type MarketHoldingMaxAggregateInputType = {
    id?: true
    playerId?: true
    gameId?: true
    symbol?: true
    quantity?: true
    avgPrice?: true
  }

  export type MarketHoldingCountAggregateInputType = {
    id?: true
    playerId?: true
    gameId?: true
    symbol?: true
    quantity?: true
    avgPrice?: true
    _all?: true
  }

  export type MarketHoldingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketHolding to aggregate.
     */
    where?: MarketHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketHoldings to fetch.
     */
    orderBy?: MarketHoldingOrderByWithRelationInput | MarketHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketHoldings
    **/
    _count?: true | MarketHoldingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketHoldingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketHoldingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketHoldingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketHoldingMaxAggregateInputType
  }

  export type GetMarketHoldingAggregateType<T extends MarketHoldingAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketHolding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketHolding[P]>
      : GetScalarType<T[P], AggregateMarketHolding[P]>
  }




  export type MarketHoldingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketHoldingWhereInput
    orderBy?: MarketHoldingOrderByWithAggregationInput | MarketHoldingOrderByWithAggregationInput[]
    by: MarketHoldingScalarFieldEnum[] | MarketHoldingScalarFieldEnum
    having?: MarketHoldingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketHoldingCountAggregateInputType | true
    _avg?: MarketHoldingAvgAggregateInputType
    _sum?: MarketHoldingSumAggregateInputType
    _min?: MarketHoldingMinAggregateInputType
    _max?: MarketHoldingMaxAggregateInputType
  }

  export type MarketHoldingGroupByOutputType = {
    id: string
    playerId: string
    gameId: string
    symbol: string
    quantity: number
    avgPrice: number
    _count: MarketHoldingCountAggregateOutputType | null
    _avg: MarketHoldingAvgAggregateOutputType | null
    _sum: MarketHoldingSumAggregateOutputType | null
    _min: MarketHoldingMinAggregateOutputType | null
    _max: MarketHoldingMaxAggregateOutputType | null
  }

  type GetMarketHoldingGroupByPayload<T extends MarketHoldingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketHoldingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketHoldingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketHoldingGroupByOutputType[P]>
            : GetScalarType<T[P], MarketHoldingGroupByOutputType[P]>
        }
      >
    >


  export type MarketHoldingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    gameId?: boolean
    symbol?: boolean
    quantity?: boolean
    avgPrice?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketHolding"]>

  export type MarketHoldingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    gameId?: boolean
    symbol?: boolean
    quantity?: boolean
    avgPrice?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketHolding"]>

  export type MarketHoldingSelectScalar = {
    id?: boolean
    playerId?: boolean
    gameId?: boolean
    symbol?: boolean
    quantity?: boolean
    avgPrice?: boolean
  }

  export type MarketHoldingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type MarketHoldingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $MarketHoldingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketHolding"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      gameId: string
      symbol: string
      quantity: number
      avgPrice: number
    }, ExtArgs["result"]["marketHolding"]>
    composites: {}
  }

  type MarketHoldingGetPayload<S extends boolean | null | undefined | MarketHoldingDefaultArgs> = $Result.GetResult<Prisma.$MarketHoldingPayload, S>

  type MarketHoldingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketHoldingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketHoldingCountAggregateInputType | true
    }

  export interface MarketHoldingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketHolding'], meta: { name: 'MarketHolding' } }
    /**
     * Find zero or one MarketHolding that matches the filter.
     * @param {MarketHoldingFindUniqueArgs} args - Arguments to find a MarketHolding
     * @example
     * // Get one MarketHolding
     * const marketHolding = await prisma.marketHolding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketHoldingFindUniqueArgs>(args: SelectSubset<T, MarketHoldingFindUniqueArgs<ExtArgs>>): Prisma__MarketHoldingClient<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketHolding that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketHoldingFindUniqueOrThrowArgs} args - Arguments to find a MarketHolding
     * @example
     * // Get one MarketHolding
     * const marketHolding = await prisma.marketHolding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketHoldingFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketHoldingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketHoldingClient<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketHolding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketHoldingFindFirstArgs} args - Arguments to find a MarketHolding
     * @example
     * // Get one MarketHolding
     * const marketHolding = await prisma.marketHolding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketHoldingFindFirstArgs>(args?: SelectSubset<T, MarketHoldingFindFirstArgs<ExtArgs>>): Prisma__MarketHoldingClient<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketHolding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketHoldingFindFirstOrThrowArgs} args - Arguments to find a MarketHolding
     * @example
     * // Get one MarketHolding
     * const marketHolding = await prisma.marketHolding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketHoldingFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketHoldingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketHoldingClient<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketHoldings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketHoldingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketHoldings
     * const marketHoldings = await prisma.marketHolding.findMany()
     * 
     * // Get first 10 MarketHoldings
     * const marketHoldings = await prisma.marketHolding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketHoldingWithIdOnly = await prisma.marketHolding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketHoldingFindManyArgs>(args?: SelectSubset<T, MarketHoldingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketHolding.
     * @param {MarketHoldingCreateArgs} args - Arguments to create a MarketHolding.
     * @example
     * // Create one MarketHolding
     * const MarketHolding = await prisma.marketHolding.create({
     *   data: {
     *     // ... data to create a MarketHolding
     *   }
     * })
     * 
     */
    create<T extends MarketHoldingCreateArgs>(args: SelectSubset<T, MarketHoldingCreateArgs<ExtArgs>>): Prisma__MarketHoldingClient<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketHoldings.
     * @param {MarketHoldingCreateManyArgs} args - Arguments to create many MarketHoldings.
     * @example
     * // Create many MarketHoldings
     * const marketHolding = await prisma.marketHolding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketHoldingCreateManyArgs>(args?: SelectSubset<T, MarketHoldingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketHoldings and returns the data saved in the database.
     * @param {MarketHoldingCreateManyAndReturnArgs} args - Arguments to create many MarketHoldings.
     * @example
     * // Create many MarketHoldings
     * const marketHolding = await prisma.marketHolding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketHoldings and only return the `id`
     * const marketHoldingWithIdOnly = await prisma.marketHolding.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketHoldingCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketHoldingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketHolding.
     * @param {MarketHoldingDeleteArgs} args - Arguments to delete one MarketHolding.
     * @example
     * // Delete one MarketHolding
     * const MarketHolding = await prisma.marketHolding.delete({
     *   where: {
     *     // ... filter to delete one MarketHolding
     *   }
     * })
     * 
     */
    delete<T extends MarketHoldingDeleteArgs>(args: SelectSubset<T, MarketHoldingDeleteArgs<ExtArgs>>): Prisma__MarketHoldingClient<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketHolding.
     * @param {MarketHoldingUpdateArgs} args - Arguments to update one MarketHolding.
     * @example
     * // Update one MarketHolding
     * const marketHolding = await prisma.marketHolding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketHoldingUpdateArgs>(args: SelectSubset<T, MarketHoldingUpdateArgs<ExtArgs>>): Prisma__MarketHoldingClient<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketHoldings.
     * @param {MarketHoldingDeleteManyArgs} args - Arguments to filter MarketHoldings to delete.
     * @example
     * // Delete a few MarketHoldings
     * const { count } = await prisma.marketHolding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketHoldingDeleteManyArgs>(args?: SelectSubset<T, MarketHoldingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketHoldingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketHoldings
     * const marketHolding = await prisma.marketHolding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketHoldingUpdateManyArgs>(args: SelectSubset<T, MarketHoldingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketHolding.
     * @param {MarketHoldingUpsertArgs} args - Arguments to update or create a MarketHolding.
     * @example
     * // Update or create a MarketHolding
     * const marketHolding = await prisma.marketHolding.upsert({
     *   create: {
     *     // ... data to create a MarketHolding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketHolding we want to update
     *   }
     * })
     */
    upsert<T extends MarketHoldingUpsertArgs>(args: SelectSubset<T, MarketHoldingUpsertArgs<ExtArgs>>): Prisma__MarketHoldingClient<$Result.GetResult<Prisma.$MarketHoldingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketHoldingCountArgs} args - Arguments to filter MarketHoldings to count.
     * @example
     * // Count the number of MarketHoldings
     * const count = await prisma.marketHolding.count({
     *   where: {
     *     // ... the filter for the MarketHoldings we want to count
     *   }
     * })
    **/
    count<T extends MarketHoldingCountArgs>(
      args?: Subset<T, MarketHoldingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketHoldingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketHolding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketHoldingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketHoldingAggregateArgs>(args: Subset<T, MarketHoldingAggregateArgs>): Prisma.PrismaPromise<GetMarketHoldingAggregateType<T>>

    /**
     * Group by MarketHolding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketHoldingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketHoldingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketHoldingGroupByArgs['orderBy'] }
        : { orderBy?: MarketHoldingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketHoldingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketHoldingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketHolding model
   */
  readonly fields: MarketHoldingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketHolding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketHoldingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketHolding model
   */ 
  interface MarketHoldingFieldRefs {
    readonly id: FieldRef<"MarketHolding", 'String'>
    readonly playerId: FieldRef<"MarketHolding", 'String'>
    readonly gameId: FieldRef<"MarketHolding", 'String'>
    readonly symbol: FieldRef<"MarketHolding", 'String'>
    readonly quantity: FieldRef<"MarketHolding", 'Float'>
    readonly avgPrice: FieldRef<"MarketHolding", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * MarketHolding findUnique
   */
  export type MarketHoldingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    /**
     * Filter, which MarketHolding to fetch.
     */
    where: MarketHoldingWhereUniqueInput
  }

  /**
   * MarketHolding findUniqueOrThrow
   */
  export type MarketHoldingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    /**
     * Filter, which MarketHolding to fetch.
     */
    where: MarketHoldingWhereUniqueInput
  }

  /**
   * MarketHolding findFirst
   */
  export type MarketHoldingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    /**
     * Filter, which MarketHolding to fetch.
     */
    where?: MarketHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketHoldings to fetch.
     */
    orderBy?: MarketHoldingOrderByWithRelationInput | MarketHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketHoldings.
     */
    cursor?: MarketHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketHoldings.
     */
    distinct?: MarketHoldingScalarFieldEnum | MarketHoldingScalarFieldEnum[]
  }

  /**
   * MarketHolding findFirstOrThrow
   */
  export type MarketHoldingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    /**
     * Filter, which MarketHolding to fetch.
     */
    where?: MarketHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketHoldings to fetch.
     */
    orderBy?: MarketHoldingOrderByWithRelationInput | MarketHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketHoldings.
     */
    cursor?: MarketHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketHoldings.
     */
    distinct?: MarketHoldingScalarFieldEnum | MarketHoldingScalarFieldEnum[]
  }

  /**
   * MarketHolding findMany
   */
  export type MarketHoldingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    /**
     * Filter, which MarketHoldings to fetch.
     */
    where?: MarketHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketHoldings to fetch.
     */
    orderBy?: MarketHoldingOrderByWithRelationInput | MarketHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketHoldings.
     */
    cursor?: MarketHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketHoldings.
     */
    skip?: number
    distinct?: MarketHoldingScalarFieldEnum | MarketHoldingScalarFieldEnum[]
  }

  /**
   * MarketHolding create
   */
  export type MarketHoldingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketHolding.
     */
    data: XOR<MarketHoldingCreateInput, MarketHoldingUncheckedCreateInput>
  }

  /**
   * MarketHolding createMany
   */
  export type MarketHoldingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketHoldings.
     */
    data: MarketHoldingCreateManyInput | MarketHoldingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketHolding createManyAndReturn
   */
  export type MarketHoldingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketHoldings.
     */
    data: MarketHoldingCreateManyInput | MarketHoldingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketHolding update
   */
  export type MarketHoldingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketHolding.
     */
    data: XOR<MarketHoldingUpdateInput, MarketHoldingUncheckedUpdateInput>
    /**
     * Choose, which MarketHolding to update.
     */
    where: MarketHoldingWhereUniqueInput
  }

  /**
   * MarketHolding updateMany
   */
  export type MarketHoldingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketHoldings.
     */
    data: XOR<MarketHoldingUpdateManyMutationInput, MarketHoldingUncheckedUpdateManyInput>
    /**
     * Filter which MarketHoldings to update
     */
    where?: MarketHoldingWhereInput
  }

  /**
   * MarketHolding upsert
   */
  export type MarketHoldingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketHolding to update in case it exists.
     */
    where: MarketHoldingWhereUniqueInput
    /**
     * In case the MarketHolding found by the `where` argument doesn't exist, create a new MarketHolding with this data.
     */
    create: XOR<MarketHoldingCreateInput, MarketHoldingUncheckedCreateInput>
    /**
     * In case the MarketHolding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketHoldingUpdateInput, MarketHoldingUncheckedUpdateInput>
  }

  /**
   * MarketHolding delete
   */
  export type MarketHoldingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
    /**
     * Filter which MarketHolding to delete.
     */
    where: MarketHoldingWhereUniqueInput
  }

  /**
   * MarketHolding deleteMany
   */
  export type MarketHoldingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketHoldings to delete
     */
    where?: MarketHoldingWhereInput
  }

  /**
   * MarketHolding without action
   */
  export type MarketHoldingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketHolding
     */
    select?: MarketHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketHoldingInclude<ExtArgs> | null
  }


  /**
   * Model MarketTick
   */

  export type AggregateMarketTick = {
    _count: MarketTickCountAggregateOutputType | null
    _avg: MarketTickAvgAggregateOutputType | null
    _sum: MarketTickSumAggregateOutputType | null
    _min: MarketTickMinAggregateOutputType | null
    _max: MarketTickMaxAggregateOutputType | null
  }

  export type MarketTickAvgAggregateOutputType = {
    price: number | null
  }

  export type MarketTickSumAggregateOutputType = {
    price: number | null
  }

  export type MarketTickMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    symbol: string | null
    price: number | null
    at: Date | null
  }

  export type MarketTickMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    symbol: string | null
    price: number | null
    at: Date | null
  }

  export type MarketTickCountAggregateOutputType = {
    id: number
    gameId: number
    symbol: number
    price: number
    at: number
    _all: number
  }


  export type MarketTickAvgAggregateInputType = {
    price?: true
  }

  export type MarketTickSumAggregateInputType = {
    price?: true
  }

  export type MarketTickMinAggregateInputType = {
    id?: true
    gameId?: true
    symbol?: true
    price?: true
    at?: true
  }

  export type MarketTickMaxAggregateInputType = {
    id?: true
    gameId?: true
    symbol?: true
    price?: true
    at?: true
  }

  export type MarketTickCountAggregateInputType = {
    id?: true
    gameId?: true
    symbol?: true
    price?: true
    at?: true
    _all?: true
  }

  export type MarketTickAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketTick to aggregate.
     */
    where?: MarketTickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTicks to fetch.
     */
    orderBy?: MarketTickOrderByWithRelationInput | MarketTickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketTickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketTicks
    **/
    _count?: true | MarketTickCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketTickAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketTickSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketTickMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketTickMaxAggregateInputType
  }

  export type GetMarketTickAggregateType<T extends MarketTickAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketTick]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketTick[P]>
      : GetScalarType<T[P], AggregateMarketTick[P]>
  }




  export type MarketTickGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketTickWhereInput
    orderBy?: MarketTickOrderByWithAggregationInput | MarketTickOrderByWithAggregationInput[]
    by: MarketTickScalarFieldEnum[] | MarketTickScalarFieldEnum
    having?: MarketTickScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketTickCountAggregateInputType | true
    _avg?: MarketTickAvgAggregateInputType
    _sum?: MarketTickSumAggregateInputType
    _min?: MarketTickMinAggregateInputType
    _max?: MarketTickMaxAggregateInputType
  }

  export type MarketTickGroupByOutputType = {
    id: string
    gameId: string
    symbol: string
    price: number
    at: Date
    _count: MarketTickCountAggregateOutputType | null
    _avg: MarketTickAvgAggregateOutputType | null
    _sum: MarketTickSumAggregateOutputType | null
    _min: MarketTickMinAggregateOutputType | null
    _max: MarketTickMaxAggregateOutputType | null
  }

  type GetMarketTickGroupByPayload<T extends MarketTickGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketTickGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketTickGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketTickGroupByOutputType[P]>
            : GetScalarType<T[P], MarketTickGroupByOutputType[P]>
        }
      >
    >


  export type MarketTickSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    symbol?: boolean
    price?: boolean
    at?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketTick"]>

  export type MarketTickSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    symbol?: boolean
    price?: boolean
    at?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketTick"]>

  export type MarketTickSelectScalar = {
    id?: boolean
    gameId?: boolean
    symbol?: boolean
    price?: boolean
    at?: boolean
  }

  export type MarketTickInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type MarketTickIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $MarketTickPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketTick"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      symbol: string
      price: number
      at: Date
    }, ExtArgs["result"]["marketTick"]>
    composites: {}
  }

  type MarketTickGetPayload<S extends boolean | null | undefined | MarketTickDefaultArgs> = $Result.GetResult<Prisma.$MarketTickPayload, S>

  type MarketTickCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketTickFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketTickCountAggregateInputType | true
    }

  export interface MarketTickDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketTick'], meta: { name: 'MarketTick' } }
    /**
     * Find zero or one MarketTick that matches the filter.
     * @param {MarketTickFindUniqueArgs} args - Arguments to find a MarketTick
     * @example
     * // Get one MarketTick
     * const marketTick = await prisma.marketTick.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketTickFindUniqueArgs>(args: SelectSubset<T, MarketTickFindUniqueArgs<ExtArgs>>): Prisma__MarketTickClient<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketTick that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketTickFindUniqueOrThrowArgs} args - Arguments to find a MarketTick
     * @example
     * // Get one MarketTick
     * const marketTick = await prisma.marketTick.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketTickFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketTickFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketTickClient<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketTick that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTickFindFirstArgs} args - Arguments to find a MarketTick
     * @example
     * // Get one MarketTick
     * const marketTick = await prisma.marketTick.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketTickFindFirstArgs>(args?: SelectSubset<T, MarketTickFindFirstArgs<ExtArgs>>): Prisma__MarketTickClient<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketTick that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTickFindFirstOrThrowArgs} args - Arguments to find a MarketTick
     * @example
     * // Get one MarketTick
     * const marketTick = await prisma.marketTick.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketTickFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketTickFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketTickClient<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketTicks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTickFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketTicks
     * const marketTicks = await prisma.marketTick.findMany()
     * 
     * // Get first 10 MarketTicks
     * const marketTicks = await prisma.marketTick.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketTickWithIdOnly = await prisma.marketTick.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketTickFindManyArgs>(args?: SelectSubset<T, MarketTickFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketTick.
     * @param {MarketTickCreateArgs} args - Arguments to create a MarketTick.
     * @example
     * // Create one MarketTick
     * const MarketTick = await prisma.marketTick.create({
     *   data: {
     *     // ... data to create a MarketTick
     *   }
     * })
     * 
     */
    create<T extends MarketTickCreateArgs>(args: SelectSubset<T, MarketTickCreateArgs<ExtArgs>>): Prisma__MarketTickClient<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketTicks.
     * @param {MarketTickCreateManyArgs} args - Arguments to create many MarketTicks.
     * @example
     * // Create many MarketTicks
     * const marketTick = await prisma.marketTick.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketTickCreateManyArgs>(args?: SelectSubset<T, MarketTickCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketTicks and returns the data saved in the database.
     * @param {MarketTickCreateManyAndReturnArgs} args - Arguments to create many MarketTicks.
     * @example
     * // Create many MarketTicks
     * const marketTick = await prisma.marketTick.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketTicks and only return the `id`
     * const marketTickWithIdOnly = await prisma.marketTick.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketTickCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketTickCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketTick.
     * @param {MarketTickDeleteArgs} args - Arguments to delete one MarketTick.
     * @example
     * // Delete one MarketTick
     * const MarketTick = await prisma.marketTick.delete({
     *   where: {
     *     // ... filter to delete one MarketTick
     *   }
     * })
     * 
     */
    delete<T extends MarketTickDeleteArgs>(args: SelectSubset<T, MarketTickDeleteArgs<ExtArgs>>): Prisma__MarketTickClient<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketTick.
     * @param {MarketTickUpdateArgs} args - Arguments to update one MarketTick.
     * @example
     * // Update one MarketTick
     * const marketTick = await prisma.marketTick.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketTickUpdateArgs>(args: SelectSubset<T, MarketTickUpdateArgs<ExtArgs>>): Prisma__MarketTickClient<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketTicks.
     * @param {MarketTickDeleteManyArgs} args - Arguments to filter MarketTicks to delete.
     * @example
     * // Delete a few MarketTicks
     * const { count } = await prisma.marketTick.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketTickDeleteManyArgs>(args?: SelectSubset<T, MarketTickDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketTicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTickUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketTicks
     * const marketTick = await prisma.marketTick.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketTickUpdateManyArgs>(args: SelectSubset<T, MarketTickUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketTick.
     * @param {MarketTickUpsertArgs} args - Arguments to update or create a MarketTick.
     * @example
     * // Update or create a MarketTick
     * const marketTick = await prisma.marketTick.upsert({
     *   create: {
     *     // ... data to create a MarketTick
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketTick we want to update
     *   }
     * })
     */
    upsert<T extends MarketTickUpsertArgs>(args: SelectSubset<T, MarketTickUpsertArgs<ExtArgs>>): Prisma__MarketTickClient<$Result.GetResult<Prisma.$MarketTickPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketTicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTickCountArgs} args - Arguments to filter MarketTicks to count.
     * @example
     * // Count the number of MarketTicks
     * const count = await prisma.marketTick.count({
     *   where: {
     *     // ... the filter for the MarketTicks we want to count
     *   }
     * })
    **/
    count<T extends MarketTickCountArgs>(
      args?: Subset<T, MarketTickCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketTickCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketTick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTickAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketTickAggregateArgs>(args: Subset<T, MarketTickAggregateArgs>): Prisma.PrismaPromise<GetMarketTickAggregateType<T>>

    /**
     * Group by MarketTick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTickGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketTickGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketTickGroupByArgs['orderBy'] }
        : { orderBy?: MarketTickGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketTickGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketTickGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketTick model
   */
  readonly fields: MarketTickFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketTick.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketTickClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketTick model
   */ 
  interface MarketTickFieldRefs {
    readonly id: FieldRef<"MarketTick", 'String'>
    readonly gameId: FieldRef<"MarketTick", 'String'>
    readonly symbol: FieldRef<"MarketTick", 'String'>
    readonly price: FieldRef<"MarketTick", 'Float'>
    readonly at: FieldRef<"MarketTick", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketTick findUnique
   */
  export type MarketTickFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
    /**
     * Filter, which MarketTick to fetch.
     */
    where: MarketTickWhereUniqueInput
  }

  /**
   * MarketTick findUniqueOrThrow
   */
  export type MarketTickFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
    /**
     * Filter, which MarketTick to fetch.
     */
    where: MarketTickWhereUniqueInput
  }

  /**
   * MarketTick findFirst
   */
  export type MarketTickFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
    /**
     * Filter, which MarketTick to fetch.
     */
    where?: MarketTickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTicks to fetch.
     */
    orderBy?: MarketTickOrderByWithRelationInput | MarketTickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketTicks.
     */
    cursor?: MarketTickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketTicks.
     */
    distinct?: MarketTickScalarFieldEnum | MarketTickScalarFieldEnum[]
  }

  /**
   * MarketTick findFirstOrThrow
   */
  export type MarketTickFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
    /**
     * Filter, which MarketTick to fetch.
     */
    where?: MarketTickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTicks to fetch.
     */
    orderBy?: MarketTickOrderByWithRelationInput | MarketTickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketTicks.
     */
    cursor?: MarketTickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketTicks.
     */
    distinct?: MarketTickScalarFieldEnum | MarketTickScalarFieldEnum[]
  }

  /**
   * MarketTick findMany
   */
  export type MarketTickFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
    /**
     * Filter, which MarketTicks to fetch.
     */
    where?: MarketTickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTicks to fetch.
     */
    orderBy?: MarketTickOrderByWithRelationInput | MarketTickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketTicks.
     */
    cursor?: MarketTickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTicks.
     */
    skip?: number
    distinct?: MarketTickScalarFieldEnum | MarketTickScalarFieldEnum[]
  }

  /**
   * MarketTick create
   */
  export type MarketTickCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketTick.
     */
    data: XOR<MarketTickCreateInput, MarketTickUncheckedCreateInput>
  }

  /**
   * MarketTick createMany
   */
  export type MarketTickCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketTicks.
     */
    data: MarketTickCreateManyInput | MarketTickCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketTick createManyAndReturn
   */
  export type MarketTickCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketTicks.
     */
    data: MarketTickCreateManyInput | MarketTickCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketTick update
   */
  export type MarketTickUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketTick.
     */
    data: XOR<MarketTickUpdateInput, MarketTickUncheckedUpdateInput>
    /**
     * Choose, which MarketTick to update.
     */
    where: MarketTickWhereUniqueInput
  }

  /**
   * MarketTick updateMany
   */
  export type MarketTickUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketTicks.
     */
    data: XOR<MarketTickUpdateManyMutationInput, MarketTickUncheckedUpdateManyInput>
    /**
     * Filter which MarketTicks to update
     */
    where?: MarketTickWhereInput
  }

  /**
   * MarketTick upsert
   */
  export type MarketTickUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketTick to update in case it exists.
     */
    where: MarketTickWhereUniqueInput
    /**
     * In case the MarketTick found by the `where` argument doesn't exist, create a new MarketTick with this data.
     */
    create: XOR<MarketTickCreateInput, MarketTickUncheckedCreateInput>
    /**
     * In case the MarketTick was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketTickUpdateInput, MarketTickUncheckedUpdateInput>
  }

  /**
   * MarketTick delete
   */
  export type MarketTickDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
    /**
     * Filter which MarketTick to delete.
     */
    where: MarketTickWhereUniqueInput
  }

  /**
   * MarketTick deleteMany
   */
  export type MarketTickDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketTicks to delete
     */
    where?: MarketTickWhereInput
  }

  /**
   * MarketTick without action
   */
  export type MarketTickDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTick
     */
    select?: MarketTickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketTickInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    nickname: 'nickname',
    cash: 'cash',
    netWorth: 'netWorth',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    gameId: 'gameId',
    guestId: 'guestId'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    code: 'code',
    status: 'status',
    createdAt: 'createdAt',
    startedAt: 'startedAt',
    updatedAt: 'updatedAt'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const PropertyTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    city: 'city',
    imageUrl: 'imageUrl',
    price: 'price',
    baseRent: 'baseRent',
    taxes: 'taxes',
    insurance: 'insurance',
    maintenance: 'maintenance'
  };

  export type PropertyTemplateScalarFieldEnum = (typeof PropertyTemplateScalarFieldEnum)[keyof typeof PropertyTemplateScalarFieldEnum]


  export const PropertyHoldingScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    templateId: 'templateId',
    gameId: 'gameId',
    purchasePrice: 'purchasePrice',
    currentValue: 'currentValue',
    currentRent: 'currentRent',
    mortgageRate: 'mortgageRate',
    mortgageDebt: 'mortgageDebt',
    weeklyPayment: 'weeklyPayment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyHoldingScalarFieldEnum = (typeof PropertyHoldingScalarFieldEnum)[keyof typeof PropertyHoldingScalarFieldEnum]


  export const RepairEventScalarFieldEnum: {
    id: 'id',
    holdingId: 'holdingId',
    type: 'type',
    cost: 'cost',
    impact: 'impact',
    createdAt: 'createdAt'
  };

  export type RepairEventScalarFieldEnum = (typeof RepairEventScalarFieldEnum)[keyof typeof RepairEventScalarFieldEnum]


  export const RefinanceLogScalarFieldEnum: {
    id: 'id',
    holdingId: 'holdingId',
    amount: 'amount',
    rate: 'rate',
    at: 'at'
  };

  export type RefinanceLogScalarFieldEnum = (typeof RefinanceLogScalarFieldEnum)[keyof typeof RefinanceLogScalarFieldEnum]


  export const ListingScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    holdingId: 'holdingId',
    templateId: 'templateId',
    sellerId: 'sellerId',
    price: 'price',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type ListingScalarFieldEnum = (typeof ListingScalarFieldEnum)[keyof typeof ListingScalarFieldEnum]


  export const MarketHoldingScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    gameId: 'gameId',
    symbol: 'symbol',
    quantity: 'quantity',
    avgPrice: 'avgPrice'
  };

  export type MarketHoldingScalarFieldEnum = (typeof MarketHoldingScalarFieldEnum)[keyof typeof MarketHoldingScalarFieldEnum]


  export const MarketTickScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    symbol: 'symbol',
    price: 'price',
    at: 'at'
  };

  export type MarketTickScalarFieldEnum = (typeof MarketTickScalarFieldEnum)[keyof typeof MarketTickScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: StringFilter<"Player"> | string
    nickname?: StringFilter<"Player"> | string
    cash?: FloatFilter<"Player"> | number
    netWorth?: FloatFilter<"Player"> | number
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    gameId?: StringNullableFilter<"Player"> | string | null
    guestId?: StringFilter<"Player"> | string
    game?: XOR<GameNullableRelationFilter, GameWhereInput> | null
    properties?: PropertyHoldingListRelationFilter
    markets?: MarketHoldingListRelationFilter
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    nickname?: SortOrder
    cash?: SortOrder
    netWorth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameId?: SortOrderInput | SortOrder
    guestId?: SortOrder
    game?: GameOrderByWithRelationInput
    properties?: PropertyHoldingOrderByRelationAggregateInput
    markets?: MarketHoldingOrderByRelationAggregateInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId_guestId?: PlayerGameIdGuestIdCompoundUniqueInput
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    nickname?: StringFilter<"Player"> | string
    cash?: FloatFilter<"Player"> | number
    netWorth?: FloatFilter<"Player"> | number
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    gameId?: StringNullableFilter<"Player"> | string | null
    guestId?: StringFilter<"Player"> | string
    game?: XOR<GameNullableRelationFilter, GameWhereInput> | null
    properties?: PropertyHoldingListRelationFilter
    markets?: MarketHoldingListRelationFilter
  }, "id" | "gameId_guestId">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    nickname?: SortOrder
    cash?: SortOrder
    netWorth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameId?: SortOrderInput | SortOrder
    guestId?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Player"> | string
    nickname?: StringWithAggregatesFilter<"Player"> | string
    cash?: FloatWithAggregatesFilter<"Player"> | number
    netWorth?: FloatWithAggregatesFilter<"Player"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    gameId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    guestId?: StringWithAggregatesFilter<"Player"> | string
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    code?: StringFilter<"Game"> | string
    status?: StringFilter<"Game"> | string
    createdAt?: DateTimeFilter<"Game"> | Date | string
    startedAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    players?: PlayerListRelationFilter
    marketTicks?: MarketTickListRelationFilter
    propertyHoldings?: PropertyHoldingListRelationFilter
    listings?: ListingListRelationFilter
    marketHoldings?: MarketHoldingListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    players?: PlayerOrderByRelationAggregateInput
    marketTicks?: MarketTickOrderByRelationAggregateInput
    propertyHoldings?: PropertyHoldingOrderByRelationAggregateInput
    listings?: ListingOrderByRelationAggregateInput
    marketHoldings?: MarketHoldingOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    status?: StringFilter<"Game"> | string
    createdAt?: DateTimeFilter<"Game"> | Date | string
    startedAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    players?: PlayerListRelationFilter
    marketTicks?: MarketTickListRelationFilter
    propertyHoldings?: PropertyHoldingListRelationFilter
    listings?: ListingListRelationFilter
    marketHoldings?: MarketHoldingListRelationFilter
  }, "id" | "code">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: GameCountOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    code?: StringWithAggregatesFilter<"Game"> | string
    status?: StringWithAggregatesFilter<"Game"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
  }

  export type PropertyTemplateWhereInput = {
    AND?: PropertyTemplateWhereInput | PropertyTemplateWhereInput[]
    OR?: PropertyTemplateWhereInput[]
    NOT?: PropertyTemplateWhereInput | PropertyTemplateWhereInput[]
    id?: StringFilter<"PropertyTemplate"> | string
    name?: StringFilter<"PropertyTemplate"> | string
    city?: StringFilter<"PropertyTemplate"> | string
    imageUrl?: StringFilter<"PropertyTemplate"> | string
    price?: FloatFilter<"PropertyTemplate"> | number
    baseRent?: FloatFilter<"PropertyTemplate"> | number
    taxes?: FloatFilter<"PropertyTemplate"> | number
    insurance?: FloatFilter<"PropertyTemplate"> | number
    maintenance?: FloatFilter<"PropertyTemplate"> | number
    holdings?: PropertyHoldingListRelationFilter
    listings?: ListingListRelationFilter
  }

  export type PropertyTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    baseRent?: SortOrder
    taxes?: SortOrder
    insurance?: SortOrder
    maintenance?: SortOrder
    holdings?: PropertyHoldingOrderByRelationAggregateInput
    listings?: ListingOrderByRelationAggregateInput
  }

  export type PropertyTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyTemplateWhereInput | PropertyTemplateWhereInput[]
    OR?: PropertyTemplateWhereInput[]
    NOT?: PropertyTemplateWhereInput | PropertyTemplateWhereInput[]
    name?: StringFilter<"PropertyTemplate"> | string
    city?: StringFilter<"PropertyTemplate"> | string
    imageUrl?: StringFilter<"PropertyTemplate"> | string
    price?: FloatFilter<"PropertyTemplate"> | number
    baseRent?: FloatFilter<"PropertyTemplate"> | number
    taxes?: FloatFilter<"PropertyTemplate"> | number
    insurance?: FloatFilter<"PropertyTemplate"> | number
    maintenance?: FloatFilter<"PropertyTemplate"> | number
    holdings?: PropertyHoldingListRelationFilter
    listings?: ListingListRelationFilter
  }, "id">

  export type PropertyTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    baseRent?: SortOrder
    taxes?: SortOrder
    insurance?: SortOrder
    maintenance?: SortOrder
    _count?: PropertyTemplateCountOrderByAggregateInput
    _avg?: PropertyTemplateAvgOrderByAggregateInput
    _max?: PropertyTemplateMaxOrderByAggregateInput
    _min?: PropertyTemplateMinOrderByAggregateInput
    _sum?: PropertyTemplateSumOrderByAggregateInput
  }

  export type PropertyTemplateScalarWhereWithAggregatesInput = {
    AND?: PropertyTemplateScalarWhereWithAggregatesInput | PropertyTemplateScalarWhereWithAggregatesInput[]
    OR?: PropertyTemplateScalarWhereWithAggregatesInput[]
    NOT?: PropertyTemplateScalarWhereWithAggregatesInput | PropertyTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyTemplate"> | string
    name?: StringWithAggregatesFilter<"PropertyTemplate"> | string
    city?: StringWithAggregatesFilter<"PropertyTemplate"> | string
    imageUrl?: StringWithAggregatesFilter<"PropertyTemplate"> | string
    price?: FloatWithAggregatesFilter<"PropertyTemplate"> | number
    baseRent?: FloatWithAggregatesFilter<"PropertyTemplate"> | number
    taxes?: FloatWithAggregatesFilter<"PropertyTemplate"> | number
    insurance?: FloatWithAggregatesFilter<"PropertyTemplate"> | number
    maintenance?: FloatWithAggregatesFilter<"PropertyTemplate"> | number
  }

  export type PropertyHoldingWhereInput = {
    AND?: PropertyHoldingWhereInput | PropertyHoldingWhereInput[]
    OR?: PropertyHoldingWhereInput[]
    NOT?: PropertyHoldingWhereInput | PropertyHoldingWhereInput[]
    id?: StringFilter<"PropertyHolding"> | string
    playerId?: StringFilter<"PropertyHolding"> | string
    templateId?: StringFilter<"PropertyHolding"> | string
    gameId?: StringFilter<"PropertyHolding"> | string
    purchasePrice?: FloatFilter<"PropertyHolding"> | number
    currentValue?: FloatFilter<"PropertyHolding"> | number
    currentRent?: FloatFilter<"PropertyHolding"> | number
    mortgageRate?: FloatFilter<"PropertyHolding"> | number
    mortgageDebt?: FloatFilter<"PropertyHolding"> | number
    weeklyPayment?: FloatFilter<"PropertyHolding"> | number
    createdAt?: DateTimeFilter<"PropertyHolding"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyHolding"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    template?: XOR<PropertyTemplateRelationFilter, PropertyTemplateWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    events?: RepairEventListRelationFilter
    refinanceLogs?: RefinanceLogListRelationFilter
    listings?: ListingListRelationFilter
  }

  export type PropertyHoldingOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    templateId?: SortOrder
    gameId?: SortOrder
    purchasePrice?: SortOrder
    currentValue?: SortOrder
    currentRent?: SortOrder
    mortgageRate?: SortOrder
    mortgageDebt?: SortOrder
    weeklyPayment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    template?: PropertyTemplateOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    events?: RepairEventOrderByRelationAggregateInput
    refinanceLogs?: RefinanceLogOrderByRelationAggregateInput
    listings?: ListingOrderByRelationAggregateInput
  }

  export type PropertyHoldingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyHoldingWhereInput | PropertyHoldingWhereInput[]
    OR?: PropertyHoldingWhereInput[]
    NOT?: PropertyHoldingWhereInput | PropertyHoldingWhereInput[]
    playerId?: StringFilter<"PropertyHolding"> | string
    templateId?: StringFilter<"PropertyHolding"> | string
    gameId?: StringFilter<"PropertyHolding"> | string
    purchasePrice?: FloatFilter<"PropertyHolding"> | number
    currentValue?: FloatFilter<"PropertyHolding"> | number
    currentRent?: FloatFilter<"PropertyHolding"> | number
    mortgageRate?: FloatFilter<"PropertyHolding"> | number
    mortgageDebt?: FloatFilter<"PropertyHolding"> | number
    weeklyPayment?: FloatFilter<"PropertyHolding"> | number
    createdAt?: DateTimeFilter<"PropertyHolding"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyHolding"> | Date | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    template?: XOR<PropertyTemplateRelationFilter, PropertyTemplateWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    events?: RepairEventListRelationFilter
    refinanceLogs?: RefinanceLogListRelationFilter
    listings?: ListingListRelationFilter
  }, "id">

  export type PropertyHoldingOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    templateId?: SortOrder
    gameId?: SortOrder
    purchasePrice?: SortOrder
    currentValue?: SortOrder
    currentRent?: SortOrder
    mortgageRate?: SortOrder
    mortgageDebt?: SortOrder
    weeklyPayment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyHoldingCountOrderByAggregateInput
    _avg?: PropertyHoldingAvgOrderByAggregateInput
    _max?: PropertyHoldingMaxOrderByAggregateInput
    _min?: PropertyHoldingMinOrderByAggregateInput
    _sum?: PropertyHoldingSumOrderByAggregateInput
  }

  export type PropertyHoldingScalarWhereWithAggregatesInput = {
    AND?: PropertyHoldingScalarWhereWithAggregatesInput | PropertyHoldingScalarWhereWithAggregatesInput[]
    OR?: PropertyHoldingScalarWhereWithAggregatesInput[]
    NOT?: PropertyHoldingScalarWhereWithAggregatesInput | PropertyHoldingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyHolding"> | string
    playerId?: StringWithAggregatesFilter<"PropertyHolding"> | string
    templateId?: StringWithAggregatesFilter<"PropertyHolding"> | string
    gameId?: StringWithAggregatesFilter<"PropertyHolding"> | string
    purchasePrice?: FloatWithAggregatesFilter<"PropertyHolding"> | number
    currentValue?: FloatWithAggregatesFilter<"PropertyHolding"> | number
    currentRent?: FloatWithAggregatesFilter<"PropertyHolding"> | number
    mortgageRate?: FloatWithAggregatesFilter<"PropertyHolding"> | number
    mortgageDebt?: FloatWithAggregatesFilter<"PropertyHolding"> | number
    weeklyPayment?: FloatWithAggregatesFilter<"PropertyHolding"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PropertyHolding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyHolding"> | Date | string
  }

  export type RepairEventWhereInput = {
    AND?: RepairEventWhereInput | RepairEventWhereInput[]
    OR?: RepairEventWhereInput[]
    NOT?: RepairEventWhereInput | RepairEventWhereInput[]
    id?: StringFilter<"RepairEvent"> | string
    holdingId?: StringFilter<"RepairEvent"> | string
    type?: StringFilter<"RepairEvent"> | string
    cost?: FloatFilter<"RepairEvent"> | number
    impact?: StringFilter<"RepairEvent"> | string
    createdAt?: DateTimeFilter<"RepairEvent"> | Date | string
    holding?: XOR<PropertyHoldingRelationFilter, PropertyHoldingWhereInput>
  }

  export type RepairEventOrderByWithRelationInput = {
    id?: SortOrder
    holdingId?: SortOrder
    type?: SortOrder
    cost?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
    holding?: PropertyHoldingOrderByWithRelationInput
  }

  export type RepairEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RepairEventWhereInput | RepairEventWhereInput[]
    OR?: RepairEventWhereInput[]
    NOT?: RepairEventWhereInput | RepairEventWhereInput[]
    holdingId?: StringFilter<"RepairEvent"> | string
    type?: StringFilter<"RepairEvent"> | string
    cost?: FloatFilter<"RepairEvent"> | number
    impact?: StringFilter<"RepairEvent"> | string
    createdAt?: DateTimeFilter<"RepairEvent"> | Date | string
    holding?: XOR<PropertyHoldingRelationFilter, PropertyHoldingWhereInput>
  }, "id">

  export type RepairEventOrderByWithAggregationInput = {
    id?: SortOrder
    holdingId?: SortOrder
    type?: SortOrder
    cost?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
    _count?: RepairEventCountOrderByAggregateInput
    _avg?: RepairEventAvgOrderByAggregateInput
    _max?: RepairEventMaxOrderByAggregateInput
    _min?: RepairEventMinOrderByAggregateInput
    _sum?: RepairEventSumOrderByAggregateInput
  }

  export type RepairEventScalarWhereWithAggregatesInput = {
    AND?: RepairEventScalarWhereWithAggregatesInput | RepairEventScalarWhereWithAggregatesInput[]
    OR?: RepairEventScalarWhereWithAggregatesInput[]
    NOT?: RepairEventScalarWhereWithAggregatesInput | RepairEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RepairEvent"> | string
    holdingId?: StringWithAggregatesFilter<"RepairEvent"> | string
    type?: StringWithAggregatesFilter<"RepairEvent"> | string
    cost?: FloatWithAggregatesFilter<"RepairEvent"> | number
    impact?: StringWithAggregatesFilter<"RepairEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RepairEvent"> | Date | string
  }

  export type RefinanceLogWhereInput = {
    AND?: RefinanceLogWhereInput | RefinanceLogWhereInput[]
    OR?: RefinanceLogWhereInput[]
    NOT?: RefinanceLogWhereInput | RefinanceLogWhereInput[]
    id?: StringFilter<"RefinanceLog"> | string
    holdingId?: StringFilter<"RefinanceLog"> | string
    amount?: FloatFilter<"RefinanceLog"> | number
    rate?: FloatFilter<"RefinanceLog"> | number
    at?: DateTimeFilter<"RefinanceLog"> | Date | string
    holding?: XOR<PropertyHoldingRelationFilter, PropertyHoldingWhereInput>
  }

  export type RefinanceLogOrderByWithRelationInput = {
    id?: SortOrder
    holdingId?: SortOrder
    amount?: SortOrder
    rate?: SortOrder
    at?: SortOrder
    holding?: PropertyHoldingOrderByWithRelationInput
  }

  export type RefinanceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefinanceLogWhereInput | RefinanceLogWhereInput[]
    OR?: RefinanceLogWhereInput[]
    NOT?: RefinanceLogWhereInput | RefinanceLogWhereInput[]
    holdingId?: StringFilter<"RefinanceLog"> | string
    amount?: FloatFilter<"RefinanceLog"> | number
    rate?: FloatFilter<"RefinanceLog"> | number
    at?: DateTimeFilter<"RefinanceLog"> | Date | string
    holding?: XOR<PropertyHoldingRelationFilter, PropertyHoldingWhereInput>
  }, "id">

  export type RefinanceLogOrderByWithAggregationInput = {
    id?: SortOrder
    holdingId?: SortOrder
    amount?: SortOrder
    rate?: SortOrder
    at?: SortOrder
    _count?: RefinanceLogCountOrderByAggregateInput
    _avg?: RefinanceLogAvgOrderByAggregateInput
    _max?: RefinanceLogMaxOrderByAggregateInput
    _min?: RefinanceLogMinOrderByAggregateInput
    _sum?: RefinanceLogSumOrderByAggregateInput
  }

  export type RefinanceLogScalarWhereWithAggregatesInput = {
    AND?: RefinanceLogScalarWhereWithAggregatesInput | RefinanceLogScalarWhereWithAggregatesInput[]
    OR?: RefinanceLogScalarWhereWithAggregatesInput[]
    NOT?: RefinanceLogScalarWhereWithAggregatesInput | RefinanceLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefinanceLog"> | string
    holdingId?: StringWithAggregatesFilter<"RefinanceLog"> | string
    amount?: FloatWithAggregatesFilter<"RefinanceLog"> | number
    rate?: FloatWithAggregatesFilter<"RefinanceLog"> | number
    at?: DateTimeWithAggregatesFilter<"RefinanceLog"> | Date | string
  }

  export type ListingWhereInput = {
    AND?: ListingWhereInput | ListingWhereInput[]
    OR?: ListingWhereInput[]
    NOT?: ListingWhereInput | ListingWhereInput[]
    id?: StringFilter<"Listing"> | string
    gameId?: StringFilter<"Listing"> | string
    holdingId?: StringNullableFilter<"Listing"> | string | null
    templateId?: StringNullableFilter<"Listing"> | string | null
    sellerId?: StringNullableFilter<"Listing"> | string | null
    price?: FloatFilter<"Listing"> | number
    type?: StringFilter<"Listing"> | string
    createdAt?: DateTimeFilter<"Listing"> | Date | string
    game?: XOR<GameRelationFilter, GameWhereInput>
    holding?: XOR<PropertyHoldingNullableRelationFilter, PropertyHoldingWhereInput> | null
    template?: XOR<PropertyTemplateNullableRelationFilter, PropertyTemplateWhereInput> | null
  }

  export type ListingOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    holdingId?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    sellerId?: SortOrderInput | SortOrder
    price?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    game?: GameOrderByWithRelationInput
    holding?: PropertyHoldingOrderByWithRelationInput
    template?: PropertyTemplateOrderByWithRelationInput
  }

  export type ListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListingWhereInput | ListingWhereInput[]
    OR?: ListingWhereInput[]
    NOT?: ListingWhereInput | ListingWhereInput[]
    gameId?: StringFilter<"Listing"> | string
    holdingId?: StringNullableFilter<"Listing"> | string | null
    templateId?: StringNullableFilter<"Listing"> | string | null
    sellerId?: StringNullableFilter<"Listing"> | string | null
    price?: FloatFilter<"Listing"> | number
    type?: StringFilter<"Listing"> | string
    createdAt?: DateTimeFilter<"Listing"> | Date | string
    game?: XOR<GameRelationFilter, GameWhereInput>
    holding?: XOR<PropertyHoldingNullableRelationFilter, PropertyHoldingWhereInput> | null
    template?: XOR<PropertyTemplateNullableRelationFilter, PropertyTemplateWhereInput> | null
  }, "id">

  export type ListingOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    holdingId?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    sellerId?: SortOrderInput | SortOrder
    price?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: ListingCountOrderByAggregateInput
    _avg?: ListingAvgOrderByAggregateInput
    _max?: ListingMaxOrderByAggregateInput
    _min?: ListingMinOrderByAggregateInput
    _sum?: ListingSumOrderByAggregateInput
  }

  export type ListingScalarWhereWithAggregatesInput = {
    AND?: ListingScalarWhereWithAggregatesInput | ListingScalarWhereWithAggregatesInput[]
    OR?: ListingScalarWhereWithAggregatesInput[]
    NOT?: ListingScalarWhereWithAggregatesInput | ListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Listing"> | string
    gameId?: StringWithAggregatesFilter<"Listing"> | string
    holdingId?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    templateId?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    sellerId?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    price?: FloatWithAggregatesFilter<"Listing"> | number
    type?: StringWithAggregatesFilter<"Listing"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Listing"> | Date | string
  }

  export type MarketHoldingWhereInput = {
    AND?: MarketHoldingWhereInput | MarketHoldingWhereInput[]
    OR?: MarketHoldingWhereInput[]
    NOT?: MarketHoldingWhereInput | MarketHoldingWhereInput[]
    id?: StringFilter<"MarketHolding"> | string
    playerId?: StringFilter<"MarketHolding"> | string
    gameId?: StringFilter<"MarketHolding"> | string
    symbol?: StringFilter<"MarketHolding"> | string
    quantity?: FloatFilter<"MarketHolding"> | number
    avgPrice?: FloatFilter<"MarketHolding"> | number
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type MarketHoldingOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    symbol?: SortOrder
    quantity?: SortOrder
    avgPrice?: SortOrder
    player?: PlayerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type MarketHoldingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_gameId_symbol?: MarketHoldingPlayerIdGameIdSymbolCompoundUniqueInput
    AND?: MarketHoldingWhereInput | MarketHoldingWhereInput[]
    OR?: MarketHoldingWhereInput[]
    NOT?: MarketHoldingWhereInput | MarketHoldingWhereInput[]
    playerId?: StringFilter<"MarketHolding"> | string
    gameId?: StringFilter<"MarketHolding"> | string
    symbol?: StringFilter<"MarketHolding"> | string
    quantity?: FloatFilter<"MarketHolding"> | number
    avgPrice?: FloatFilter<"MarketHolding"> | number
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id" | "playerId_gameId_symbol">

  export type MarketHoldingOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    symbol?: SortOrder
    quantity?: SortOrder
    avgPrice?: SortOrder
    _count?: MarketHoldingCountOrderByAggregateInput
    _avg?: MarketHoldingAvgOrderByAggregateInput
    _max?: MarketHoldingMaxOrderByAggregateInput
    _min?: MarketHoldingMinOrderByAggregateInput
    _sum?: MarketHoldingSumOrderByAggregateInput
  }

  export type MarketHoldingScalarWhereWithAggregatesInput = {
    AND?: MarketHoldingScalarWhereWithAggregatesInput | MarketHoldingScalarWhereWithAggregatesInput[]
    OR?: MarketHoldingScalarWhereWithAggregatesInput[]
    NOT?: MarketHoldingScalarWhereWithAggregatesInput | MarketHoldingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketHolding"> | string
    playerId?: StringWithAggregatesFilter<"MarketHolding"> | string
    gameId?: StringWithAggregatesFilter<"MarketHolding"> | string
    symbol?: StringWithAggregatesFilter<"MarketHolding"> | string
    quantity?: FloatWithAggregatesFilter<"MarketHolding"> | number
    avgPrice?: FloatWithAggregatesFilter<"MarketHolding"> | number
  }

  export type MarketTickWhereInput = {
    AND?: MarketTickWhereInput | MarketTickWhereInput[]
    OR?: MarketTickWhereInput[]
    NOT?: MarketTickWhereInput | MarketTickWhereInput[]
    id?: StringFilter<"MarketTick"> | string
    gameId?: StringFilter<"MarketTick"> | string
    symbol?: StringFilter<"MarketTick"> | string
    price?: FloatFilter<"MarketTick"> | number
    at?: DateTimeFilter<"MarketTick"> | Date | string
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type MarketTickOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    symbol?: SortOrder
    price?: SortOrder
    at?: SortOrder
    game?: GameOrderByWithRelationInput
  }

  export type MarketTickWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketTickWhereInput | MarketTickWhereInput[]
    OR?: MarketTickWhereInput[]
    NOT?: MarketTickWhereInput | MarketTickWhereInput[]
    gameId?: StringFilter<"MarketTick"> | string
    symbol?: StringFilter<"MarketTick"> | string
    price?: FloatFilter<"MarketTick"> | number
    at?: DateTimeFilter<"MarketTick"> | Date | string
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type MarketTickOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    symbol?: SortOrder
    price?: SortOrder
    at?: SortOrder
    _count?: MarketTickCountOrderByAggregateInput
    _avg?: MarketTickAvgOrderByAggregateInput
    _max?: MarketTickMaxOrderByAggregateInput
    _min?: MarketTickMinOrderByAggregateInput
    _sum?: MarketTickSumOrderByAggregateInput
  }

  export type MarketTickScalarWhereWithAggregatesInput = {
    AND?: MarketTickScalarWhereWithAggregatesInput | MarketTickScalarWhereWithAggregatesInput[]
    OR?: MarketTickScalarWhereWithAggregatesInput[]
    NOT?: MarketTickScalarWhereWithAggregatesInput | MarketTickScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketTick"> | string
    gameId?: StringWithAggregatesFilter<"MarketTick"> | string
    symbol?: StringWithAggregatesFilter<"MarketTick"> | string
    price?: FloatWithAggregatesFilter<"MarketTick"> | number
    at?: DateTimeWithAggregatesFilter<"MarketTick"> | Date | string
  }

  export type PlayerCreateInput = {
    id?: string
    nickname: string
    cash?: number
    netWorth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    guestId: string
    game?: GameCreateNestedOneWithoutPlayersInput
    properties?: PropertyHoldingCreateNestedManyWithoutPlayerInput
    markets?: MarketHoldingCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: string
    nickname: string
    cash?: number
    netWorth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    gameId?: string | null
    guestId: string
    properties?: PropertyHoldingUncheckedCreateNestedManyWithoutPlayerInput
    markets?: MarketHoldingUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: StringFieldUpdateOperationsInput | string
    game?: GameUpdateOneWithoutPlayersNestedInput
    properties?: PropertyHoldingUpdateManyWithoutPlayerNestedInput
    markets?: MarketHoldingUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyHoldingUncheckedUpdateManyWithoutPlayerNestedInput
    markets?: MarketHoldingUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: string
    nickname: string
    cash?: number
    netWorth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    gameId?: string | null
    guestId: string
  }

  export type PlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: StringFieldUpdateOperationsInput | string
  }

  export type GameCreateInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    players?: PlayerCreateNestedManyWithoutGameInput
    marketTicks?: MarketTickCreateNestedManyWithoutGameInput
    propertyHoldings?: PropertyHoldingCreateNestedManyWithoutGameInput
    listings?: ListingCreateNestedManyWithoutGameInput
    marketHoldings?: MarketHoldingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    players?: PlayerUncheckedCreateNestedManyWithoutGameInput
    marketTicks?: MarketTickUncheckedCreateNestedManyWithoutGameInput
    propertyHoldings?: PropertyHoldingUncheckedCreateNestedManyWithoutGameInput
    listings?: ListingUncheckedCreateNestedManyWithoutGameInput
    marketHoldings?: MarketHoldingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUpdateManyWithoutGameNestedInput
    marketTicks?: MarketTickUpdateManyWithoutGameNestedInput
    propertyHoldings?: PropertyHoldingUpdateManyWithoutGameNestedInput
    listings?: ListingUpdateManyWithoutGameNestedInput
    marketHoldings?: MarketHoldingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUncheckedUpdateManyWithoutGameNestedInput
    marketTicks?: MarketTickUncheckedUpdateManyWithoutGameNestedInput
    propertyHoldings?: PropertyHoldingUncheckedUpdateManyWithoutGameNestedInput
    listings?: ListingUncheckedUpdateManyWithoutGameNestedInput
    marketHoldings?: MarketHoldingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTemplateCreateInput = {
    id?: string
    name: string
    city: string
    imageUrl: string
    price: number
    baseRent: number
    taxes: number
    insurance: number
    maintenance: number
    holdings?: PropertyHoldingCreateNestedManyWithoutTemplateInput
    listings?: ListingCreateNestedManyWithoutTemplateInput
  }

  export type PropertyTemplateUncheckedCreateInput = {
    id?: string
    name: string
    city: string
    imageUrl: string
    price: number
    baseRent: number
    taxes: number
    insurance: number
    maintenance: number
    holdings?: PropertyHoldingUncheckedCreateNestedManyWithoutTemplateInput
    listings?: ListingUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type PropertyTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    baseRent?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    maintenance?: FloatFieldUpdateOperationsInput | number
    holdings?: PropertyHoldingUpdateManyWithoutTemplateNestedInput
    listings?: ListingUpdateManyWithoutTemplateNestedInput
  }

  export type PropertyTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    baseRent?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    maintenance?: FloatFieldUpdateOperationsInput | number
    holdings?: PropertyHoldingUncheckedUpdateManyWithoutTemplateNestedInput
    listings?: ListingUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type PropertyTemplateCreateManyInput = {
    id?: string
    name: string
    city: string
    imageUrl: string
    price: number
    baseRent: number
    taxes: number
    insurance: number
    maintenance: number
  }

  export type PropertyTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    baseRent?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    maintenance?: FloatFieldUpdateOperationsInput | number
  }

  export type PropertyTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    baseRent?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    maintenance?: FloatFieldUpdateOperationsInput | number
  }

  export type PropertyHoldingCreateInput = {
    id?: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutPropertiesInput
    template: PropertyTemplateCreateNestedOneWithoutHoldingsInput
    game: GameCreateNestedOneWithoutPropertyHoldingsInput
    events?: RepairEventCreateNestedManyWithoutHoldingInput
    refinanceLogs?: RefinanceLogCreateNestedManyWithoutHoldingInput
    listings?: ListingCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingUncheckedCreateInput = {
    id?: string
    playerId: string
    templateId: string
    gameId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: RepairEventUncheckedCreateNestedManyWithoutHoldingInput
    refinanceLogs?: RefinanceLogUncheckedCreateNestedManyWithoutHoldingInput
    listings?: ListingUncheckedCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPropertiesNestedInput
    template?: PropertyTemplateUpdateOneRequiredWithoutHoldingsNestedInput
    game?: GameUpdateOneRequiredWithoutPropertyHoldingsNestedInput
    events?: RepairEventUpdateManyWithoutHoldingNestedInput
    refinanceLogs?: RefinanceLogUpdateManyWithoutHoldingNestedInput
    listings?: ListingUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: RepairEventUncheckedUpdateManyWithoutHoldingNestedInput
    refinanceLogs?: RefinanceLogUncheckedUpdateManyWithoutHoldingNestedInput
    listings?: ListingUncheckedUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingCreateManyInput = {
    id?: string
    playerId: string
    templateId: string
    gameId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyHoldingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyHoldingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairEventCreateInput = {
    id?: string
    type: string
    cost: number
    impact: string
    createdAt?: Date | string
    holding: PropertyHoldingCreateNestedOneWithoutEventsInput
  }

  export type RepairEventUncheckedCreateInput = {
    id?: string
    holdingId: string
    type: string
    cost: number
    impact: string
    createdAt?: Date | string
  }

  export type RepairEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holding?: PropertyHoldingUpdateOneRequiredWithoutEventsNestedInput
  }

  export type RepairEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    holdingId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairEventCreateManyInput = {
    id?: string
    holdingId: string
    type: string
    cost: number
    impact: string
    createdAt?: Date | string
  }

  export type RepairEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    holdingId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefinanceLogCreateInput = {
    id?: string
    amount: number
    rate: number
    at?: Date | string
    holding: PropertyHoldingCreateNestedOneWithoutRefinanceLogsInput
  }

  export type RefinanceLogUncheckedCreateInput = {
    id?: string
    holdingId: string
    amount: number
    rate: number
    at?: Date | string
  }

  export type RefinanceLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
    holding?: PropertyHoldingUpdateOneRequiredWithoutRefinanceLogsNestedInput
  }

  export type RefinanceLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    holdingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefinanceLogCreateManyInput = {
    id?: string
    holdingId: string
    amount: number
    rate: number
    at?: Date | string
  }

  export type RefinanceLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefinanceLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    holdingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingCreateInput = {
    id?: string
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
    game: GameCreateNestedOneWithoutListingsInput
    holding?: PropertyHoldingCreateNestedOneWithoutListingsInput
    template?: PropertyTemplateCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateInput = {
    id?: string
    gameId: string
    holdingId?: string | null
    templateId?: string | null
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
  }

  export type ListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutListingsNestedInput
    holding?: PropertyHoldingUpdateOneWithoutListingsNestedInput
    template?: PropertyTemplateUpdateOneWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    holdingId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingCreateManyInput = {
    id?: string
    gameId: string
    holdingId?: string | null
    templateId?: string | null
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
  }

  export type ListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    holdingId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketHoldingCreateInput = {
    id?: string
    symbol: string
    quantity: number
    avgPrice: number
    player: PlayerCreateNestedOneWithoutMarketsInput
    game: GameCreateNestedOneWithoutMarketHoldingsInput
  }

  export type MarketHoldingUncheckedCreateInput = {
    id?: string
    playerId: string
    gameId: string
    symbol: string
    quantity: number
    avgPrice: number
  }

  export type MarketHoldingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    avgPrice?: FloatFieldUpdateOperationsInput | number
    player?: PlayerUpdateOneRequiredWithoutMarketsNestedInput
    game?: GameUpdateOneRequiredWithoutMarketHoldingsNestedInput
  }

  export type MarketHoldingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    avgPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type MarketHoldingCreateManyInput = {
    id?: string
    playerId: string
    gameId: string
    symbol: string
    quantity: number
    avgPrice: number
  }

  export type MarketHoldingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    avgPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type MarketHoldingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    avgPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type MarketTickCreateInput = {
    id?: string
    symbol: string
    price: number
    at?: Date | string
    game: GameCreateNestedOneWithoutMarketTicksInput
  }

  export type MarketTickUncheckedCreateInput = {
    id?: string
    gameId: string
    symbol: string
    price: number
    at?: Date | string
  }

  export type MarketTickUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutMarketTicksNestedInput
  }

  export type MarketTickUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTickCreateManyInput = {
    id?: string
    gameId: string
    symbol: string
    price: number
    at?: Date | string
  }

  export type MarketTickUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTickUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type GameNullableRelationFilter = {
    is?: GameWhereInput | null
    isNot?: GameWhereInput | null
  }

  export type PropertyHoldingListRelationFilter = {
    every?: PropertyHoldingWhereInput
    some?: PropertyHoldingWhereInput
    none?: PropertyHoldingWhereInput
  }

  export type MarketHoldingListRelationFilter = {
    every?: MarketHoldingWhereInput
    some?: MarketHoldingWhereInput
    none?: MarketHoldingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PropertyHoldingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketHoldingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerGameIdGuestIdCompoundUniqueInput = {
    gameId: string
    guestId: string
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    cash?: SortOrder
    netWorth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameId?: SortOrder
    guestId?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    cash?: SortOrder
    netWorth?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    cash?: SortOrder
    netWorth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameId?: SortOrder
    guestId?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    cash?: SortOrder
    netWorth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameId?: SortOrder
    guestId?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    cash?: SortOrder
    netWorth?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PlayerListRelationFilter = {
    every?: PlayerWhereInput
    some?: PlayerWhereInput
    none?: PlayerWhereInput
  }

  export type MarketTickListRelationFilter = {
    every?: MarketTickWhereInput
    some?: MarketTickWhereInput
    none?: MarketTickWhereInput
  }

  export type ListingListRelationFilter = {
    every?: ListingWhereInput
    some?: ListingWhereInput
    none?: ListingWhereInput
  }

  export type PlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketTickOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PropertyTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    baseRent?: SortOrder
    taxes?: SortOrder
    insurance?: SortOrder
    maintenance?: SortOrder
  }

  export type PropertyTemplateAvgOrderByAggregateInput = {
    price?: SortOrder
    baseRent?: SortOrder
    taxes?: SortOrder
    insurance?: SortOrder
    maintenance?: SortOrder
  }

  export type PropertyTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    baseRent?: SortOrder
    taxes?: SortOrder
    insurance?: SortOrder
    maintenance?: SortOrder
  }

  export type PropertyTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    baseRent?: SortOrder
    taxes?: SortOrder
    insurance?: SortOrder
    maintenance?: SortOrder
  }

  export type PropertyTemplateSumOrderByAggregateInput = {
    price?: SortOrder
    baseRent?: SortOrder
    taxes?: SortOrder
    insurance?: SortOrder
    maintenance?: SortOrder
  }

  export type PlayerRelationFilter = {
    is?: PlayerWhereInput
    isNot?: PlayerWhereInput
  }

  export type PropertyTemplateRelationFilter = {
    is?: PropertyTemplateWhereInput
    isNot?: PropertyTemplateWhereInput
  }

  export type GameRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type RepairEventListRelationFilter = {
    every?: RepairEventWhereInput
    some?: RepairEventWhereInput
    none?: RepairEventWhereInput
  }

  export type RefinanceLogListRelationFilter = {
    every?: RefinanceLogWhereInput
    some?: RefinanceLogWhereInput
    none?: RefinanceLogWhereInput
  }

  export type RepairEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefinanceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyHoldingCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    templateId?: SortOrder
    gameId?: SortOrder
    purchasePrice?: SortOrder
    currentValue?: SortOrder
    currentRent?: SortOrder
    mortgageRate?: SortOrder
    mortgageDebt?: SortOrder
    weeklyPayment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyHoldingAvgOrderByAggregateInput = {
    purchasePrice?: SortOrder
    currentValue?: SortOrder
    currentRent?: SortOrder
    mortgageRate?: SortOrder
    mortgageDebt?: SortOrder
    weeklyPayment?: SortOrder
  }

  export type PropertyHoldingMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    templateId?: SortOrder
    gameId?: SortOrder
    purchasePrice?: SortOrder
    currentValue?: SortOrder
    currentRent?: SortOrder
    mortgageRate?: SortOrder
    mortgageDebt?: SortOrder
    weeklyPayment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyHoldingMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    templateId?: SortOrder
    gameId?: SortOrder
    purchasePrice?: SortOrder
    currentValue?: SortOrder
    currentRent?: SortOrder
    mortgageRate?: SortOrder
    mortgageDebt?: SortOrder
    weeklyPayment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyHoldingSumOrderByAggregateInput = {
    purchasePrice?: SortOrder
    currentValue?: SortOrder
    currentRent?: SortOrder
    mortgageRate?: SortOrder
    mortgageDebt?: SortOrder
    weeklyPayment?: SortOrder
  }

  export type PropertyHoldingRelationFilter = {
    is?: PropertyHoldingWhereInput
    isNot?: PropertyHoldingWhereInput
  }

  export type RepairEventCountOrderByAggregateInput = {
    id?: SortOrder
    holdingId?: SortOrder
    type?: SortOrder
    cost?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairEventAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type RepairEventMaxOrderByAggregateInput = {
    id?: SortOrder
    holdingId?: SortOrder
    type?: SortOrder
    cost?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairEventMinOrderByAggregateInput = {
    id?: SortOrder
    holdingId?: SortOrder
    type?: SortOrder
    cost?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairEventSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type RefinanceLogCountOrderByAggregateInput = {
    id?: SortOrder
    holdingId?: SortOrder
    amount?: SortOrder
    rate?: SortOrder
    at?: SortOrder
  }

  export type RefinanceLogAvgOrderByAggregateInput = {
    amount?: SortOrder
    rate?: SortOrder
  }

  export type RefinanceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    holdingId?: SortOrder
    amount?: SortOrder
    rate?: SortOrder
    at?: SortOrder
  }

  export type RefinanceLogMinOrderByAggregateInput = {
    id?: SortOrder
    holdingId?: SortOrder
    amount?: SortOrder
    rate?: SortOrder
    at?: SortOrder
  }

  export type RefinanceLogSumOrderByAggregateInput = {
    amount?: SortOrder
    rate?: SortOrder
  }

  export type PropertyHoldingNullableRelationFilter = {
    is?: PropertyHoldingWhereInput | null
    isNot?: PropertyHoldingWhereInput | null
  }

  export type PropertyTemplateNullableRelationFilter = {
    is?: PropertyTemplateWhereInput | null
    isNot?: PropertyTemplateWhereInput | null
  }

  export type ListingCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    holdingId?: SortOrder
    templateId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ListingAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ListingMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    holdingId?: SortOrder
    templateId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ListingMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    holdingId?: SortOrder
    templateId?: SortOrder
    sellerId?: SortOrder
    price?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ListingSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type MarketHoldingPlayerIdGameIdSymbolCompoundUniqueInput = {
    playerId: string
    gameId: string
    symbol: string
  }

  export type MarketHoldingCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    symbol?: SortOrder
    quantity?: SortOrder
    avgPrice?: SortOrder
  }

  export type MarketHoldingAvgOrderByAggregateInput = {
    quantity?: SortOrder
    avgPrice?: SortOrder
  }

  export type MarketHoldingMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    symbol?: SortOrder
    quantity?: SortOrder
    avgPrice?: SortOrder
  }

  export type MarketHoldingMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    symbol?: SortOrder
    quantity?: SortOrder
    avgPrice?: SortOrder
  }

  export type MarketHoldingSumOrderByAggregateInput = {
    quantity?: SortOrder
    avgPrice?: SortOrder
  }

  export type MarketTickCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    symbol?: SortOrder
    price?: SortOrder
    at?: SortOrder
  }

  export type MarketTickAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type MarketTickMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    symbol?: SortOrder
    price?: SortOrder
    at?: SortOrder
  }

  export type MarketTickMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    symbol?: SortOrder
    price?: SortOrder
    at?: SortOrder
  }

  export type MarketTickSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type GameCreateNestedOneWithoutPlayersInput = {
    create?: XOR<GameCreateWithoutPlayersInput, GameUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: GameCreateOrConnectWithoutPlayersInput
    connect?: GameWhereUniqueInput
  }

  export type PropertyHoldingCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PropertyHoldingCreateWithoutPlayerInput, PropertyHoldingUncheckedCreateWithoutPlayerInput> | PropertyHoldingCreateWithoutPlayerInput[] | PropertyHoldingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutPlayerInput | PropertyHoldingCreateOrConnectWithoutPlayerInput[]
    createMany?: PropertyHoldingCreateManyPlayerInputEnvelope
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
  }

  export type MarketHoldingCreateNestedManyWithoutPlayerInput = {
    create?: XOR<MarketHoldingCreateWithoutPlayerInput, MarketHoldingUncheckedCreateWithoutPlayerInput> | MarketHoldingCreateWithoutPlayerInput[] | MarketHoldingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MarketHoldingCreateOrConnectWithoutPlayerInput | MarketHoldingCreateOrConnectWithoutPlayerInput[]
    createMany?: MarketHoldingCreateManyPlayerInputEnvelope
    connect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
  }

  export type PropertyHoldingUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PropertyHoldingCreateWithoutPlayerInput, PropertyHoldingUncheckedCreateWithoutPlayerInput> | PropertyHoldingCreateWithoutPlayerInput[] | PropertyHoldingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutPlayerInput | PropertyHoldingCreateOrConnectWithoutPlayerInput[]
    createMany?: PropertyHoldingCreateManyPlayerInputEnvelope
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
  }

  export type MarketHoldingUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<MarketHoldingCreateWithoutPlayerInput, MarketHoldingUncheckedCreateWithoutPlayerInput> | MarketHoldingCreateWithoutPlayerInput[] | MarketHoldingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MarketHoldingCreateOrConnectWithoutPlayerInput | MarketHoldingCreateOrConnectWithoutPlayerInput[]
    createMany?: MarketHoldingCreateManyPlayerInputEnvelope
    connect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type GameUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<GameCreateWithoutPlayersInput, GameUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: GameCreateOrConnectWithoutPlayersInput
    upsert?: GameUpsertWithoutPlayersInput
    disconnect?: GameWhereInput | boolean
    delete?: GameWhereInput | boolean
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutPlayersInput, GameUpdateWithoutPlayersInput>, GameUncheckedUpdateWithoutPlayersInput>
  }

  export type PropertyHoldingUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PropertyHoldingCreateWithoutPlayerInput, PropertyHoldingUncheckedCreateWithoutPlayerInput> | PropertyHoldingCreateWithoutPlayerInput[] | PropertyHoldingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutPlayerInput | PropertyHoldingCreateOrConnectWithoutPlayerInput[]
    upsert?: PropertyHoldingUpsertWithWhereUniqueWithoutPlayerInput | PropertyHoldingUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PropertyHoldingCreateManyPlayerInputEnvelope
    set?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    disconnect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    delete?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    update?: PropertyHoldingUpdateWithWhereUniqueWithoutPlayerInput | PropertyHoldingUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PropertyHoldingUpdateManyWithWhereWithoutPlayerInput | PropertyHoldingUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PropertyHoldingScalarWhereInput | PropertyHoldingScalarWhereInput[]
  }

  export type MarketHoldingUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<MarketHoldingCreateWithoutPlayerInput, MarketHoldingUncheckedCreateWithoutPlayerInput> | MarketHoldingCreateWithoutPlayerInput[] | MarketHoldingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MarketHoldingCreateOrConnectWithoutPlayerInput | MarketHoldingCreateOrConnectWithoutPlayerInput[]
    upsert?: MarketHoldingUpsertWithWhereUniqueWithoutPlayerInput | MarketHoldingUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: MarketHoldingCreateManyPlayerInputEnvelope
    set?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    disconnect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    delete?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    connect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    update?: MarketHoldingUpdateWithWhereUniqueWithoutPlayerInput | MarketHoldingUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: MarketHoldingUpdateManyWithWhereWithoutPlayerInput | MarketHoldingUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: MarketHoldingScalarWhereInput | MarketHoldingScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PropertyHoldingUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PropertyHoldingCreateWithoutPlayerInput, PropertyHoldingUncheckedCreateWithoutPlayerInput> | PropertyHoldingCreateWithoutPlayerInput[] | PropertyHoldingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutPlayerInput | PropertyHoldingCreateOrConnectWithoutPlayerInput[]
    upsert?: PropertyHoldingUpsertWithWhereUniqueWithoutPlayerInput | PropertyHoldingUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PropertyHoldingCreateManyPlayerInputEnvelope
    set?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    disconnect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    delete?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    update?: PropertyHoldingUpdateWithWhereUniqueWithoutPlayerInput | PropertyHoldingUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PropertyHoldingUpdateManyWithWhereWithoutPlayerInput | PropertyHoldingUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PropertyHoldingScalarWhereInput | PropertyHoldingScalarWhereInput[]
  }

  export type MarketHoldingUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<MarketHoldingCreateWithoutPlayerInput, MarketHoldingUncheckedCreateWithoutPlayerInput> | MarketHoldingCreateWithoutPlayerInput[] | MarketHoldingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MarketHoldingCreateOrConnectWithoutPlayerInput | MarketHoldingCreateOrConnectWithoutPlayerInput[]
    upsert?: MarketHoldingUpsertWithWhereUniqueWithoutPlayerInput | MarketHoldingUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: MarketHoldingCreateManyPlayerInputEnvelope
    set?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    disconnect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    delete?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    connect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    update?: MarketHoldingUpdateWithWhereUniqueWithoutPlayerInput | MarketHoldingUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: MarketHoldingUpdateManyWithWhereWithoutPlayerInput | MarketHoldingUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: MarketHoldingScalarWhereInput | MarketHoldingScalarWhereInput[]
  }

  export type PlayerCreateNestedManyWithoutGameInput = {
    create?: XOR<PlayerCreateWithoutGameInput, PlayerUncheckedCreateWithoutGameInput> | PlayerCreateWithoutGameInput[] | PlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutGameInput | PlayerCreateOrConnectWithoutGameInput[]
    createMany?: PlayerCreateManyGameInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type MarketTickCreateNestedManyWithoutGameInput = {
    create?: XOR<MarketTickCreateWithoutGameInput, MarketTickUncheckedCreateWithoutGameInput> | MarketTickCreateWithoutGameInput[] | MarketTickUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MarketTickCreateOrConnectWithoutGameInput | MarketTickCreateOrConnectWithoutGameInput[]
    createMany?: MarketTickCreateManyGameInputEnvelope
    connect?: MarketTickWhereUniqueInput | MarketTickWhereUniqueInput[]
  }

  export type PropertyHoldingCreateNestedManyWithoutGameInput = {
    create?: XOR<PropertyHoldingCreateWithoutGameInput, PropertyHoldingUncheckedCreateWithoutGameInput> | PropertyHoldingCreateWithoutGameInput[] | PropertyHoldingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutGameInput | PropertyHoldingCreateOrConnectWithoutGameInput[]
    createMany?: PropertyHoldingCreateManyGameInputEnvelope
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
  }

  export type ListingCreateNestedManyWithoutGameInput = {
    create?: XOR<ListingCreateWithoutGameInput, ListingUncheckedCreateWithoutGameInput> | ListingCreateWithoutGameInput[] | ListingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutGameInput | ListingCreateOrConnectWithoutGameInput[]
    createMany?: ListingCreateManyGameInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type MarketHoldingCreateNestedManyWithoutGameInput = {
    create?: XOR<MarketHoldingCreateWithoutGameInput, MarketHoldingUncheckedCreateWithoutGameInput> | MarketHoldingCreateWithoutGameInput[] | MarketHoldingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MarketHoldingCreateOrConnectWithoutGameInput | MarketHoldingCreateOrConnectWithoutGameInput[]
    createMany?: MarketHoldingCreateManyGameInputEnvelope
    connect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<PlayerCreateWithoutGameInput, PlayerUncheckedCreateWithoutGameInput> | PlayerCreateWithoutGameInput[] | PlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutGameInput | PlayerCreateOrConnectWithoutGameInput[]
    createMany?: PlayerCreateManyGameInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type MarketTickUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<MarketTickCreateWithoutGameInput, MarketTickUncheckedCreateWithoutGameInput> | MarketTickCreateWithoutGameInput[] | MarketTickUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MarketTickCreateOrConnectWithoutGameInput | MarketTickCreateOrConnectWithoutGameInput[]
    createMany?: MarketTickCreateManyGameInputEnvelope
    connect?: MarketTickWhereUniqueInput | MarketTickWhereUniqueInput[]
  }

  export type PropertyHoldingUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<PropertyHoldingCreateWithoutGameInput, PropertyHoldingUncheckedCreateWithoutGameInput> | PropertyHoldingCreateWithoutGameInput[] | PropertyHoldingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutGameInput | PropertyHoldingCreateOrConnectWithoutGameInput[]
    createMany?: PropertyHoldingCreateManyGameInputEnvelope
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<ListingCreateWithoutGameInput, ListingUncheckedCreateWithoutGameInput> | ListingCreateWithoutGameInput[] | ListingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutGameInput | ListingCreateOrConnectWithoutGameInput[]
    createMany?: ListingCreateManyGameInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type MarketHoldingUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<MarketHoldingCreateWithoutGameInput, MarketHoldingUncheckedCreateWithoutGameInput> | MarketHoldingCreateWithoutGameInput[] | MarketHoldingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MarketHoldingCreateOrConnectWithoutGameInput | MarketHoldingCreateOrConnectWithoutGameInput[]
    createMany?: MarketHoldingCreateManyGameInputEnvelope
    connect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PlayerUpdateManyWithoutGameNestedInput = {
    create?: XOR<PlayerCreateWithoutGameInput, PlayerUncheckedCreateWithoutGameInput> | PlayerCreateWithoutGameInput[] | PlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutGameInput | PlayerCreateOrConnectWithoutGameInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutGameInput | PlayerUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: PlayerCreateManyGameInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutGameInput | PlayerUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutGameInput | PlayerUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type MarketTickUpdateManyWithoutGameNestedInput = {
    create?: XOR<MarketTickCreateWithoutGameInput, MarketTickUncheckedCreateWithoutGameInput> | MarketTickCreateWithoutGameInput[] | MarketTickUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MarketTickCreateOrConnectWithoutGameInput | MarketTickCreateOrConnectWithoutGameInput[]
    upsert?: MarketTickUpsertWithWhereUniqueWithoutGameInput | MarketTickUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: MarketTickCreateManyGameInputEnvelope
    set?: MarketTickWhereUniqueInput | MarketTickWhereUniqueInput[]
    disconnect?: MarketTickWhereUniqueInput | MarketTickWhereUniqueInput[]
    delete?: MarketTickWhereUniqueInput | MarketTickWhereUniqueInput[]
    connect?: MarketTickWhereUniqueInput | MarketTickWhereUniqueInput[]
    update?: MarketTickUpdateWithWhereUniqueWithoutGameInput | MarketTickUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: MarketTickUpdateManyWithWhereWithoutGameInput | MarketTickUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: MarketTickScalarWhereInput | MarketTickScalarWhereInput[]
  }

  export type PropertyHoldingUpdateManyWithoutGameNestedInput = {
    create?: XOR<PropertyHoldingCreateWithoutGameInput, PropertyHoldingUncheckedCreateWithoutGameInput> | PropertyHoldingCreateWithoutGameInput[] | PropertyHoldingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutGameInput | PropertyHoldingCreateOrConnectWithoutGameInput[]
    upsert?: PropertyHoldingUpsertWithWhereUniqueWithoutGameInput | PropertyHoldingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: PropertyHoldingCreateManyGameInputEnvelope
    set?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    disconnect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    delete?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    update?: PropertyHoldingUpdateWithWhereUniqueWithoutGameInput | PropertyHoldingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: PropertyHoldingUpdateManyWithWhereWithoutGameInput | PropertyHoldingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: PropertyHoldingScalarWhereInput | PropertyHoldingScalarWhereInput[]
  }

  export type ListingUpdateManyWithoutGameNestedInput = {
    create?: XOR<ListingCreateWithoutGameInput, ListingUncheckedCreateWithoutGameInput> | ListingCreateWithoutGameInput[] | ListingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutGameInput | ListingCreateOrConnectWithoutGameInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutGameInput | ListingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ListingCreateManyGameInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutGameInput | ListingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutGameInput | ListingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type MarketHoldingUpdateManyWithoutGameNestedInput = {
    create?: XOR<MarketHoldingCreateWithoutGameInput, MarketHoldingUncheckedCreateWithoutGameInput> | MarketHoldingCreateWithoutGameInput[] | MarketHoldingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MarketHoldingCreateOrConnectWithoutGameInput | MarketHoldingCreateOrConnectWithoutGameInput[]
    upsert?: MarketHoldingUpsertWithWhereUniqueWithoutGameInput | MarketHoldingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: MarketHoldingCreateManyGameInputEnvelope
    set?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    disconnect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    delete?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    connect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    update?: MarketHoldingUpdateWithWhereUniqueWithoutGameInput | MarketHoldingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: MarketHoldingUpdateManyWithWhereWithoutGameInput | MarketHoldingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: MarketHoldingScalarWhereInput | MarketHoldingScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<PlayerCreateWithoutGameInput, PlayerUncheckedCreateWithoutGameInput> | PlayerCreateWithoutGameInput[] | PlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutGameInput | PlayerCreateOrConnectWithoutGameInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutGameInput | PlayerUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: PlayerCreateManyGameInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutGameInput | PlayerUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutGameInput | PlayerUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type MarketTickUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<MarketTickCreateWithoutGameInput, MarketTickUncheckedCreateWithoutGameInput> | MarketTickCreateWithoutGameInput[] | MarketTickUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MarketTickCreateOrConnectWithoutGameInput | MarketTickCreateOrConnectWithoutGameInput[]
    upsert?: MarketTickUpsertWithWhereUniqueWithoutGameInput | MarketTickUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: MarketTickCreateManyGameInputEnvelope
    set?: MarketTickWhereUniqueInput | MarketTickWhereUniqueInput[]
    disconnect?: MarketTickWhereUniqueInput | MarketTickWhereUniqueInput[]
    delete?: MarketTickWhereUniqueInput | MarketTickWhereUniqueInput[]
    connect?: MarketTickWhereUniqueInput | MarketTickWhereUniqueInput[]
    update?: MarketTickUpdateWithWhereUniqueWithoutGameInput | MarketTickUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: MarketTickUpdateManyWithWhereWithoutGameInput | MarketTickUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: MarketTickScalarWhereInput | MarketTickScalarWhereInput[]
  }

  export type PropertyHoldingUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<PropertyHoldingCreateWithoutGameInput, PropertyHoldingUncheckedCreateWithoutGameInput> | PropertyHoldingCreateWithoutGameInput[] | PropertyHoldingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutGameInput | PropertyHoldingCreateOrConnectWithoutGameInput[]
    upsert?: PropertyHoldingUpsertWithWhereUniqueWithoutGameInput | PropertyHoldingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: PropertyHoldingCreateManyGameInputEnvelope
    set?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    disconnect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    delete?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    update?: PropertyHoldingUpdateWithWhereUniqueWithoutGameInput | PropertyHoldingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: PropertyHoldingUpdateManyWithWhereWithoutGameInput | PropertyHoldingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: PropertyHoldingScalarWhereInput | PropertyHoldingScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<ListingCreateWithoutGameInput, ListingUncheckedCreateWithoutGameInput> | ListingCreateWithoutGameInput[] | ListingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutGameInput | ListingCreateOrConnectWithoutGameInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutGameInput | ListingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ListingCreateManyGameInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutGameInput | ListingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutGameInput | ListingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type MarketHoldingUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<MarketHoldingCreateWithoutGameInput, MarketHoldingUncheckedCreateWithoutGameInput> | MarketHoldingCreateWithoutGameInput[] | MarketHoldingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MarketHoldingCreateOrConnectWithoutGameInput | MarketHoldingCreateOrConnectWithoutGameInput[]
    upsert?: MarketHoldingUpsertWithWhereUniqueWithoutGameInput | MarketHoldingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: MarketHoldingCreateManyGameInputEnvelope
    set?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    disconnect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    delete?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    connect?: MarketHoldingWhereUniqueInput | MarketHoldingWhereUniqueInput[]
    update?: MarketHoldingUpdateWithWhereUniqueWithoutGameInput | MarketHoldingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: MarketHoldingUpdateManyWithWhereWithoutGameInput | MarketHoldingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: MarketHoldingScalarWhereInput | MarketHoldingScalarWhereInput[]
  }

  export type PropertyHoldingCreateNestedManyWithoutTemplateInput = {
    create?: XOR<PropertyHoldingCreateWithoutTemplateInput, PropertyHoldingUncheckedCreateWithoutTemplateInput> | PropertyHoldingCreateWithoutTemplateInput[] | PropertyHoldingUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutTemplateInput | PropertyHoldingCreateOrConnectWithoutTemplateInput[]
    createMany?: PropertyHoldingCreateManyTemplateInputEnvelope
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
  }

  export type ListingCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ListingCreateWithoutTemplateInput, ListingUncheckedCreateWithoutTemplateInput> | ListingCreateWithoutTemplateInput[] | ListingUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutTemplateInput | ListingCreateOrConnectWithoutTemplateInput[]
    createMany?: ListingCreateManyTemplateInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type PropertyHoldingUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<PropertyHoldingCreateWithoutTemplateInput, PropertyHoldingUncheckedCreateWithoutTemplateInput> | PropertyHoldingCreateWithoutTemplateInput[] | PropertyHoldingUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutTemplateInput | PropertyHoldingCreateOrConnectWithoutTemplateInput[]
    createMany?: PropertyHoldingCreateManyTemplateInputEnvelope
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ListingCreateWithoutTemplateInput, ListingUncheckedCreateWithoutTemplateInput> | ListingCreateWithoutTemplateInput[] | ListingUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutTemplateInput | ListingCreateOrConnectWithoutTemplateInput[]
    createMany?: ListingCreateManyTemplateInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type PropertyHoldingUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<PropertyHoldingCreateWithoutTemplateInput, PropertyHoldingUncheckedCreateWithoutTemplateInput> | PropertyHoldingCreateWithoutTemplateInput[] | PropertyHoldingUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutTemplateInput | PropertyHoldingCreateOrConnectWithoutTemplateInput[]
    upsert?: PropertyHoldingUpsertWithWhereUniqueWithoutTemplateInput | PropertyHoldingUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: PropertyHoldingCreateManyTemplateInputEnvelope
    set?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    disconnect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    delete?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    update?: PropertyHoldingUpdateWithWhereUniqueWithoutTemplateInput | PropertyHoldingUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: PropertyHoldingUpdateManyWithWhereWithoutTemplateInput | PropertyHoldingUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: PropertyHoldingScalarWhereInput | PropertyHoldingScalarWhereInput[]
  }

  export type ListingUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ListingCreateWithoutTemplateInput, ListingUncheckedCreateWithoutTemplateInput> | ListingCreateWithoutTemplateInput[] | ListingUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutTemplateInput | ListingCreateOrConnectWithoutTemplateInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutTemplateInput | ListingUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ListingCreateManyTemplateInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutTemplateInput | ListingUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutTemplateInput | ListingUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type PropertyHoldingUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<PropertyHoldingCreateWithoutTemplateInput, PropertyHoldingUncheckedCreateWithoutTemplateInput> | PropertyHoldingCreateWithoutTemplateInput[] | PropertyHoldingUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutTemplateInput | PropertyHoldingCreateOrConnectWithoutTemplateInput[]
    upsert?: PropertyHoldingUpsertWithWhereUniqueWithoutTemplateInput | PropertyHoldingUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: PropertyHoldingCreateManyTemplateInputEnvelope
    set?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    disconnect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    delete?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    connect?: PropertyHoldingWhereUniqueInput | PropertyHoldingWhereUniqueInput[]
    update?: PropertyHoldingUpdateWithWhereUniqueWithoutTemplateInput | PropertyHoldingUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: PropertyHoldingUpdateManyWithWhereWithoutTemplateInput | PropertyHoldingUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: PropertyHoldingScalarWhereInput | PropertyHoldingScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ListingCreateWithoutTemplateInput, ListingUncheckedCreateWithoutTemplateInput> | ListingCreateWithoutTemplateInput[] | ListingUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutTemplateInput | ListingCreateOrConnectWithoutTemplateInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutTemplateInput | ListingUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ListingCreateManyTemplateInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutTemplateInput | ListingUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutTemplateInput | ListingUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PlayerCreateWithoutPropertiesInput, PlayerUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPropertiesInput
    connect?: PlayerWhereUniqueInput
  }

  export type PropertyTemplateCreateNestedOneWithoutHoldingsInput = {
    create?: XOR<PropertyTemplateCreateWithoutHoldingsInput, PropertyTemplateUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: PropertyTemplateCreateOrConnectWithoutHoldingsInput
    connect?: PropertyTemplateWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutPropertyHoldingsInput = {
    create?: XOR<GameCreateWithoutPropertyHoldingsInput, GameUncheckedCreateWithoutPropertyHoldingsInput>
    connectOrCreate?: GameCreateOrConnectWithoutPropertyHoldingsInput
    connect?: GameWhereUniqueInput
  }

  export type RepairEventCreateNestedManyWithoutHoldingInput = {
    create?: XOR<RepairEventCreateWithoutHoldingInput, RepairEventUncheckedCreateWithoutHoldingInput> | RepairEventCreateWithoutHoldingInput[] | RepairEventUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: RepairEventCreateOrConnectWithoutHoldingInput | RepairEventCreateOrConnectWithoutHoldingInput[]
    createMany?: RepairEventCreateManyHoldingInputEnvelope
    connect?: RepairEventWhereUniqueInput | RepairEventWhereUniqueInput[]
  }

  export type RefinanceLogCreateNestedManyWithoutHoldingInput = {
    create?: XOR<RefinanceLogCreateWithoutHoldingInput, RefinanceLogUncheckedCreateWithoutHoldingInput> | RefinanceLogCreateWithoutHoldingInput[] | RefinanceLogUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: RefinanceLogCreateOrConnectWithoutHoldingInput | RefinanceLogCreateOrConnectWithoutHoldingInput[]
    createMany?: RefinanceLogCreateManyHoldingInputEnvelope
    connect?: RefinanceLogWhereUniqueInput | RefinanceLogWhereUniqueInput[]
  }

  export type ListingCreateNestedManyWithoutHoldingInput = {
    create?: XOR<ListingCreateWithoutHoldingInput, ListingUncheckedCreateWithoutHoldingInput> | ListingCreateWithoutHoldingInput[] | ListingUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutHoldingInput | ListingCreateOrConnectWithoutHoldingInput[]
    createMany?: ListingCreateManyHoldingInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type RepairEventUncheckedCreateNestedManyWithoutHoldingInput = {
    create?: XOR<RepairEventCreateWithoutHoldingInput, RepairEventUncheckedCreateWithoutHoldingInput> | RepairEventCreateWithoutHoldingInput[] | RepairEventUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: RepairEventCreateOrConnectWithoutHoldingInput | RepairEventCreateOrConnectWithoutHoldingInput[]
    createMany?: RepairEventCreateManyHoldingInputEnvelope
    connect?: RepairEventWhereUniqueInput | RepairEventWhereUniqueInput[]
  }

  export type RefinanceLogUncheckedCreateNestedManyWithoutHoldingInput = {
    create?: XOR<RefinanceLogCreateWithoutHoldingInput, RefinanceLogUncheckedCreateWithoutHoldingInput> | RefinanceLogCreateWithoutHoldingInput[] | RefinanceLogUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: RefinanceLogCreateOrConnectWithoutHoldingInput | RefinanceLogCreateOrConnectWithoutHoldingInput[]
    createMany?: RefinanceLogCreateManyHoldingInputEnvelope
    connect?: RefinanceLogWhereUniqueInput | RefinanceLogWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutHoldingInput = {
    create?: XOR<ListingCreateWithoutHoldingInput, ListingUncheckedCreateWithoutHoldingInput> | ListingCreateWithoutHoldingInput[] | ListingUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutHoldingInput | ListingCreateOrConnectWithoutHoldingInput[]
    createMany?: ListingCreateManyHoldingInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type PlayerUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<PlayerCreateWithoutPropertiesInput, PlayerUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPropertiesInput
    upsert?: PlayerUpsertWithoutPropertiesInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutPropertiesInput, PlayerUpdateWithoutPropertiesInput>, PlayerUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyTemplateUpdateOneRequiredWithoutHoldingsNestedInput = {
    create?: XOR<PropertyTemplateCreateWithoutHoldingsInput, PropertyTemplateUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: PropertyTemplateCreateOrConnectWithoutHoldingsInput
    upsert?: PropertyTemplateUpsertWithoutHoldingsInput
    connect?: PropertyTemplateWhereUniqueInput
    update?: XOR<XOR<PropertyTemplateUpdateToOneWithWhereWithoutHoldingsInput, PropertyTemplateUpdateWithoutHoldingsInput>, PropertyTemplateUncheckedUpdateWithoutHoldingsInput>
  }

  export type GameUpdateOneRequiredWithoutPropertyHoldingsNestedInput = {
    create?: XOR<GameCreateWithoutPropertyHoldingsInput, GameUncheckedCreateWithoutPropertyHoldingsInput>
    connectOrCreate?: GameCreateOrConnectWithoutPropertyHoldingsInput
    upsert?: GameUpsertWithoutPropertyHoldingsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutPropertyHoldingsInput, GameUpdateWithoutPropertyHoldingsInput>, GameUncheckedUpdateWithoutPropertyHoldingsInput>
  }

  export type RepairEventUpdateManyWithoutHoldingNestedInput = {
    create?: XOR<RepairEventCreateWithoutHoldingInput, RepairEventUncheckedCreateWithoutHoldingInput> | RepairEventCreateWithoutHoldingInput[] | RepairEventUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: RepairEventCreateOrConnectWithoutHoldingInput | RepairEventCreateOrConnectWithoutHoldingInput[]
    upsert?: RepairEventUpsertWithWhereUniqueWithoutHoldingInput | RepairEventUpsertWithWhereUniqueWithoutHoldingInput[]
    createMany?: RepairEventCreateManyHoldingInputEnvelope
    set?: RepairEventWhereUniqueInput | RepairEventWhereUniqueInput[]
    disconnect?: RepairEventWhereUniqueInput | RepairEventWhereUniqueInput[]
    delete?: RepairEventWhereUniqueInput | RepairEventWhereUniqueInput[]
    connect?: RepairEventWhereUniqueInput | RepairEventWhereUniqueInput[]
    update?: RepairEventUpdateWithWhereUniqueWithoutHoldingInput | RepairEventUpdateWithWhereUniqueWithoutHoldingInput[]
    updateMany?: RepairEventUpdateManyWithWhereWithoutHoldingInput | RepairEventUpdateManyWithWhereWithoutHoldingInput[]
    deleteMany?: RepairEventScalarWhereInput | RepairEventScalarWhereInput[]
  }

  export type RefinanceLogUpdateManyWithoutHoldingNestedInput = {
    create?: XOR<RefinanceLogCreateWithoutHoldingInput, RefinanceLogUncheckedCreateWithoutHoldingInput> | RefinanceLogCreateWithoutHoldingInput[] | RefinanceLogUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: RefinanceLogCreateOrConnectWithoutHoldingInput | RefinanceLogCreateOrConnectWithoutHoldingInput[]
    upsert?: RefinanceLogUpsertWithWhereUniqueWithoutHoldingInput | RefinanceLogUpsertWithWhereUniqueWithoutHoldingInput[]
    createMany?: RefinanceLogCreateManyHoldingInputEnvelope
    set?: RefinanceLogWhereUniqueInput | RefinanceLogWhereUniqueInput[]
    disconnect?: RefinanceLogWhereUniqueInput | RefinanceLogWhereUniqueInput[]
    delete?: RefinanceLogWhereUniqueInput | RefinanceLogWhereUniqueInput[]
    connect?: RefinanceLogWhereUniqueInput | RefinanceLogWhereUniqueInput[]
    update?: RefinanceLogUpdateWithWhereUniqueWithoutHoldingInput | RefinanceLogUpdateWithWhereUniqueWithoutHoldingInput[]
    updateMany?: RefinanceLogUpdateManyWithWhereWithoutHoldingInput | RefinanceLogUpdateManyWithWhereWithoutHoldingInput[]
    deleteMany?: RefinanceLogScalarWhereInput | RefinanceLogScalarWhereInput[]
  }

  export type ListingUpdateManyWithoutHoldingNestedInput = {
    create?: XOR<ListingCreateWithoutHoldingInput, ListingUncheckedCreateWithoutHoldingInput> | ListingCreateWithoutHoldingInput[] | ListingUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutHoldingInput | ListingCreateOrConnectWithoutHoldingInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutHoldingInput | ListingUpsertWithWhereUniqueWithoutHoldingInput[]
    createMany?: ListingCreateManyHoldingInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutHoldingInput | ListingUpdateWithWhereUniqueWithoutHoldingInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutHoldingInput | ListingUpdateManyWithWhereWithoutHoldingInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type RepairEventUncheckedUpdateManyWithoutHoldingNestedInput = {
    create?: XOR<RepairEventCreateWithoutHoldingInput, RepairEventUncheckedCreateWithoutHoldingInput> | RepairEventCreateWithoutHoldingInput[] | RepairEventUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: RepairEventCreateOrConnectWithoutHoldingInput | RepairEventCreateOrConnectWithoutHoldingInput[]
    upsert?: RepairEventUpsertWithWhereUniqueWithoutHoldingInput | RepairEventUpsertWithWhereUniqueWithoutHoldingInput[]
    createMany?: RepairEventCreateManyHoldingInputEnvelope
    set?: RepairEventWhereUniqueInput | RepairEventWhereUniqueInput[]
    disconnect?: RepairEventWhereUniqueInput | RepairEventWhereUniqueInput[]
    delete?: RepairEventWhereUniqueInput | RepairEventWhereUniqueInput[]
    connect?: RepairEventWhereUniqueInput | RepairEventWhereUniqueInput[]
    update?: RepairEventUpdateWithWhereUniqueWithoutHoldingInput | RepairEventUpdateWithWhereUniqueWithoutHoldingInput[]
    updateMany?: RepairEventUpdateManyWithWhereWithoutHoldingInput | RepairEventUpdateManyWithWhereWithoutHoldingInput[]
    deleteMany?: RepairEventScalarWhereInput | RepairEventScalarWhereInput[]
  }

  export type RefinanceLogUncheckedUpdateManyWithoutHoldingNestedInput = {
    create?: XOR<RefinanceLogCreateWithoutHoldingInput, RefinanceLogUncheckedCreateWithoutHoldingInput> | RefinanceLogCreateWithoutHoldingInput[] | RefinanceLogUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: RefinanceLogCreateOrConnectWithoutHoldingInput | RefinanceLogCreateOrConnectWithoutHoldingInput[]
    upsert?: RefinanceLogUpsertWithWhereUniqueWithoutHoldingInput | RefinanceLogUpsertWithWhereUniqueWithoutHoldingInput[]
    createMany?: RefinanceLogCreateManyHoldingInputEnvelope
    set?: RefinanceLogWhereUniqueInput | RefinanceLogWhereUniqueInput[]
    disconnect?: RefinanceLogWhereUniqueInput | RefinanceLogWhereUniqueInput[]
    delete?: RefinanceLogWhereUniqueInput | RefinanceLogWhereUniqueInput[]
    connect?: RefinanceLogWhereUniqueInput | RefinanceLogWhereUniqueInput[]
    update?: RefinanceLogUpdateWithWhereUniqueWithoutHoldingInput | RefinanceLogUpdateWithWhereUniqueWithoutHoldingInput[]
    updateMany?: RefinanceLogUpdateManyWithWhereWithoutHoldingInput | RefinanceLogUpdateManyWithWhereWithoutHoldingInput[]
    deleteMany?: RefinanceLogScalarWhereInput | RefinanceLogScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutHoldingNestedInput = {
    create?: XOR<ListingCreateWithoutHoldingInput, ListingUncheckedCreateWithoutHoldingInput> | ListingCreateWithoutHoldingInput[] | ListingUncheckedCreateWithoutHoldingInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutHoldingInput | ListingCreateOrConnectWithoutHoldingInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutHoldingInput | ListingUpsertWithWhereUniqueWithoutHoldingInput[]
    createMany?: ListingCreateManyHoldingInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutHoldingInput | ListingUpdateWithWhereUniqueWithoutHoldingInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutHoldingInput | ListingUpdateManyWithWhereWithoutHoldingInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type PropertyHoldingCreateNestedOneWithoutEventsInput = {
    create?: XOR<PropertyHoldingCreateWithoutEventsInput, PropertyHoldingUncheckedCreateWithoutEventsInput>
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutEventsInput
    connect?: PropertyHoldingWhereUniqueInput
  }

  export type PropertyHoldingUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<PropertyHoldingCreateWithoutEventsInput, PropertyHoldingUncheckedCreateWithoutEventsInput>
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutEventsInput
    upsert?: PropertyHoldingUpsertWithoutEventsInput
    connect?: PropertyHoldingWhereUniqueInput
    update?: XOR<XOR<PropertyHoldingUpdateToOneWithWhereWithoutEventsInput, PropertyHoldingUpdateWithoutEventsInput>, PropertyHoldingUncheckedUpdateWithoutEventsInput>
  }

  export type PropertyHoldingCreateNestedOneWithoutRefinanceLogsInput = {
    create?: XOR<PropertyHoldingCreateWithoutRefinanceLogsInput, PropertyHoldingUncheckedCreateWithoutRefinanceLogsInput>
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutRefinanceLogsInput
    connect?: PropertyHoldingWhereUniqueInput
  }

  export type PropertyHoldingUpdateOneRequiredWithoutRefinanceLogsNestedInput = {
    create?: XOR<PropertyHoldingCreateWithoutRefinanceLogsInput, PropertyHoldingUncheckedCreateWithoutRefinanceLogsInput>
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutRefinanceLogsInput
    upsert?: PropertyHoldingUpsertWithoutRefinanceLogsInput
    connect?: PropertyHoldingWhereUniqueInput
    update?: XOR<XOR<PropertyHoldingUpdateToOneWithWhereWithoutRefinanceLogsInput, PropertyHoldingUpdateWithoutRefinanceLogsInput>, PropertyHoldingUncheckedUpdateWithoutRefinanceLogsInput>
  }

  export type GameCreateNestedOneWithoutListingsInput = {
    create?: XOR<GameCreateWithoutListingsInput, GameUncheckedCreateWithoutListingsInput>
    connectOrCreate?: GameCreateOrConnectWithoutListingsInput
    connect?: GameWhereUniqueInput
  }

  export type PropertyHoldingCreateNestedOneWithoutListingsInput = {
    create?: XOR<PropertyHoldingCreateWithoutListingsInput, PropertyHoldingUncheckedCreateWithoutListingsInput>
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutListingsInput
    connect?: PropertyHoldingWhereUniqueInput
  }

  export type PropertyTemplateCreateNestedOneWithoutListingsInput = {
    create?: XOR<PropertyTemplateCreateWithoutListingsInput, PropertyTemplateUncheckedCreateWithoutListingsInput>
    connectOrCreate?: PropertyTemplateCreateOrConnectWithoutListingsInput
    connect?: PropertyTemplateWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<GameCreateWithoutListingsInput, GameUncheckedCreateWithoutListingsInput>
    connectOrCreate?: GameCreateOrConnectWithoutListingsInput
    upsert?: GameUpsertWithoutListingsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutListingsInput, GameUpdateWithoutListingsInput>, GameUncheckedUpdateWithoutListingsInput>
  }

  export type PropertyHoldingUpdateOneWithoutListingsNestedInput = {
    create?: XOR<PropertyHoldingCreateWithoutListingsInput, PropertyHoldingUncheckedCreateWithoutListingsInput>
    connectOrCreate?: PropertyHoldingCreateOrConnectWithoutListingsInput
    upsert?: PropertyHoldingUpsertWithoutListingsInput
    disconnect?: PropertyHoldingWhereInput | boolean
    delete?: PropertyHoldingWhereInput | boolean
    connect?: PropertyHoldingWhereUniqueInput
    update?: XOR<XOR<PropertyHoldingUpdateToOneWithWhereWithoutListingsInput, PropertyHoldingUpdateWithoutListingsInput>, PropertyHoldingUncheckedUpdateWithoutListingsInput>
  }

  export type PropertyTemplateUpdateOneWithoutListingsNestedInput = {
    create?: XOR<PropertyTemplateCreateWithoutListingsInput, PropertyTemplateUncheckedCreateWithoutListingsInput>
    connectOrCreate?: PropertyTemplateCreateOrConnectWithoutListingsInput
    upsert?: PropertyTemplateUpsertWithoutListingsInput
    disconnect?: PropertyTemplateWhereInput | boolean
    delete?: PropertyTemplateWhereInput | boolean
    connect?: PropertyTemplateWhereUniqueInput
    update?: XOR<XOR<PropertyTemplateUpdateToOneWithWhereWithoutListingsInput, PropertyTemplateUpdateWithoutListingsInput>, PropertyTemplateUncheckedUpdateWithoutListingsInput>
  }

  export type PlayerCreateNestedOneWithoutMarketsInput = {
    create?: XOR<PlayerCreateWithoutMarketsInput, PlayerUncheckedCreateWithoutMarketsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarketsInput
    connect?: PlayerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutMarketHoldingsInput = {
    create?: XOR<GameCreateWithoutMarketHoldingsInput, GameUncheckedCreateWithoutMarketHoldingsInput>
    connectOrCreate?: GameCreateOrConnectWithoutMarketHoldingsInput
    connect?: GameWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutMarketsNestedInput = {
    create?: XOR<PlayerCreateWithoutMarketsInput, PlayerUncheckedCreateWithoutMarketsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarketsInput
    upsert?: PlayerUpsertWithoutMarketsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutMarketsInput, PlayerUpdateWithoutMarketsInput>, PlayerUncheckedUpdateWithoutMarketsInput>
  }

  export type GameUpdateOneRequiredWithoutMarketHoldingsNestedInput = {
    create?: XOR<GameCreateWithoutMarketHoldingsInput, GameUncheckedCreateWithoutMarketHoldingsInput>
    connectOrCreate?: GameCreateOrConnectWithoutMarketHoldingsInput
    upsert?: GameUpsertWithoutMarketHoldingsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutMarketHoldingsInput, GameUpdateWithoutMarketHoldingsInput>, GameUncheckedUpdateWithoutMarketHoldingsInput>
  }

  export type GameCreateNestedOneWithoutMarketTicksInput = {
    create?: XOR<GameCreateWithoutMarketTicksInput, GameUncheckedCreateWithoutMarketTicksInput>
    connectOrCreate?: GameCreateOrConnectWithoutMarketTicksInput
    connect?: GameWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutMarketTicksNestedInput = {
    create?: XOR<GameCreateWithoutMarketTicksInput, GameUncheckedCreateWithoutMarketTicksInput>
    connectOrCreate?: GameCreateOrConnectWithoutMarketTicksInput
    upsert?: GameUpsertWithoutMarketTicksInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutMarketTicksInput, GameUpdateWithoutMarketTicksInput>, GameUncheckedUpdateWithoutMarketTicksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type GameCreateWithoutPlayersInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    marketTicks?: MarketTickCreateNestedManyWithoutGameInput
    propertyHoldings?: PropertyHoldingCreateNestedManyWithoutGameInput
    listings?: ListingCreateNestedManyWithoutGameInput
    marketHoldings?: MarketHoldingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutPlayersInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    marketTicks?: MarketTickUncheckedCreateNestedManyWithoutGameInput
    propertyHoldings?: PropertyHoldingUncheckedCreateNestedManyWithoutGameInput
    listings?: ListingUncheckedCreateNestedManyWithoutGameInput
    marketHoldings?: MarketHoldingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutPlayersInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutPlayersInput, GameUncheckedCreateWithoutPlayersInput>
  }

  export type PropertyHoldingCreateWithoutPlayerInput = {
    id?: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    template: PropertyTemplateCreateNestedOneWithoutHoldingsInput
    game: GameCreateNestedOneWithoutPropertyHoldingsInput
    events?: RepairEventCreateNestedManyWithoutHoldingInput
    refinanceLogs?: RefinanceLogCreateNestedManyWithoutHoldingInput
    listings?: ListingCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingUncheckedCreateWithoutPlayerInput = {
    id?: string
    templateId: string
    gameId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: RepairEventUncheckedCreateNestedManyWithoutHoldingInput
    refinanceLogs?: RefinanceLogUncheckedCreateNestedManyWithoutHoldingInput
    listings?: ListingUncheckedCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingCreateOrConnectWithoutPlayerInput = {
    where: PropertyHoldingWhereUniqueInput
    create: XOR<PropertyHoldingCreateWithoutPlayerInput, PropertyHoldingUncheckedCreateWithoutPlayerInput>
  }

  export type PropertyHoldingCreateManyPlayerInputEnvelope = {
    data: PropertyHoldingCreateManyPlayerInput | PropertyHoldingCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type MarketHoldingCreateWithoutPlayerInput = {
    id?: string
    symbol: string
    quantity: number
    avgPrice: number
    game: GameCreateNestedOneWithoutMarketHoldingsInput
  }

  export type MarketHoldingUncheckedCreateWithoutPlayerInput = {
    id?: string
    gameId: string
    symbol: string
    quantity: number
    avgPrice: number
  }

  export type MarketHoldingCreateOrConnectWithoutPlayerInput = {
    where: MarketHoldingWhereUniqueInput
    create: XOR<MarketHoldingCreateWithoutPlayerInput, MarketHoldingUncheckedCreateWithoutPlayerInput>
  }

  export type MarketHoldingCreateManyPlayerInputEnvelope = {
    data: MarketHoldingCreateManyPlayerInput | MarketHoldingCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type GameUpsertWithoutPlayersInput = {
    update: XOR<GameUpdateWithoutPlayersInput, GameUncheckedUpdateWithoutPlayersInput>
    create: XOR<GameCreateWithoutPlayersInput, GameUncheckedCreateWithoutPlayersInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutPlayersInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutPlayersInput, GameUncheckedUpdateWithoutPlayersInput>
  }

  export type GameUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketTicks?: MarketTickUpdateManyWithoutGameNestedInput
    propertyHoldings?: PropertyHoldingUpdateManyWithoutGameNestedInput
    listings?: ListingUpdateManyWithoutGameNestedInput
    marketHoldings?: MarketHoldingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketTicks?: MarketTickUncheckedUpdateManyWithoutGameNestedInput
    propertyHoldings?: PropertyHoldingUncheckedUpdateManyWithoutGameNestedInput
    listings?: ListingUncheckedUpdateManyWithoutGameNestedInput
    marketHoldings?: MarketHoldingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type PropertyHoldingUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PropertyHoldingWhereUniqueInput
    update: XOR<PropertyHoldingUpdateWithoutPlayerInput, PropertyHoldingUncheckedUpdateWithoutPlayerInput>
    create: XOR<PropertyHoldingCreateWithoutPlayerInput, PropertyHoldingUncheckedCreateWithoutPlayerInput>
  }

  export type PropertyHoldingUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PropertyHoldingWhereUniqueInput
    data: XOR<PropertyHoldingUpdateWithoutPlayerInput, PropertyHoldingUncheckedUpdateWithoutPlayerInput>
  }

  export type PropertyHoldingUpdateManyWithWhereWithoutPlayerInput = {
    where: PropertyHoldingScalarWhereInput
    data: XOR<PropertyHoldingUpdateManyMutationInput, PropertyHoldingUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PropertyHoldingScalarWhereInput = {
    AND?: PropertyHoldingScalarWhereInput | PropertyHoldingScalarWhereInput[]
    OR?: PropertyHoldingScalarWhereInput[]
    NOT?: PropertyHoldingScalarWhereInput | PropertyHoldingScalarWhereInput[]
    id?: StringFilter<"PropertyHolding"> | string
    playerId?: StringFilter<"PropertyHolding"> | string
    templateId?: StringFilter<"PropertyHolding"> | string
    gameId?: StringFilter<"PropertyHolding"> | string
    purchasePrice?: FloatFilter<"PropertyHolding"> | number
    currentValue?: FloatFilter<"PropertyHolding"> | number
    currentRent?: FloatFilter<"PropertyHolding"> | number
    mortgageRate?: FloatFilter<"PropertyHolding"> | number
    mortgageDebt?: FloatFilter<"PropertyHolding"> | number
    weeklyPayment?: FloatFilter<"PropertyHolding"> | number
    createdAt?: DateTimeFilter<"PropertyHolding"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyHolding"> | Date | string
  }

  export type MarketHoldingUpsertWithWhereUniqueWithoutPlayerInput = {
    where: MarketHoldingWhereUniqueInput
    update: XOR<MarketHoldingUpdateWithoutPlayerInput, MarketHoldingUncheckedUpdateWithoutPlayerInput>
    create: XOR<MarketHoldingCreateWithoutPlayerInput, MarketHoldingUncheckedCreateWithoutPlayerInput>
  }

  export type MarketHoldingUpdateWithWhereUniqueWithoutPlayerInput = {
    where: MarketHoldingWhereUniqueInput
    data: XOR<MarketHoldingUpdateWithoutPlayerInput, MarketHoldingUncheckedUpdateWithoutPlayerInput>
  }

  export type MarketHoldingUpdateManyWithWhereWithoutPlayerInput = {
    where: MarketHoldingScalarWhereInput
    data: XOR<MarketHoldingUpdateManyMutationInput, MarketHoldingUncheckedUpdateManyWithoutPlayerInput>
  }

  export type MarketHoldingScalarWhereInput = {
    AND?: MarketHoldingScalarWhereInput | MarketHoldingScalarWhereInput[]
    OR?: MarketHoldingScalarWhereInput[]
    NOT?: MarketHoldingScalarWhereInput | MarketHoldingScalarWhereInput[]
    id?: StringFilter<"MarketHolding"> | string
    playerId?: StringFilter<"MarketHolding"> | string
    gameId?: StringFilter<"MarketHolding"> | string
    symbol?: StringFilter<"MarketHolding"> | string
    quantity?: FloatFilter<"MarketHolding"> | number
    avgPrice?: FloatFilter<"MarketHolding"> | number
  }

  export type PlayerCreateWithoutGameInput = {
    id?: string
    nickname: string
    cash?: number
    netWorth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    guestId: string
    properties?: PropertyHoldingCreateNestedManyWithoutPlayerInput
    markets?: MarketHoldingCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutGameInput = {
    id?: string
    nickname: string
    cash?: number
    netWorth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    guestId: string
    properties?: PropertyHoldingUncheckedCreateNestedManyWithoutPlayerInput
    markets?: MarketHoldingUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutGameInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutGameInput, PlayerUncheckedCreateWithoutGameInput>
  }

  export type PlayerCreateManyGameInputEnvelope = {
    data: PlayerCreateManyGameInput | PlayerCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type MarketTickCreateWithoutGameInput = {
    id?: string
    symbol: string
    price: number
    at?: Date | string
  }

  export type MarketTickUncheckedCreateWithoutGameInput = {
    id?: string
    symbol: string
    price: number
    at?: Date | string
  }

  export type MarketTickCreateOrConnectWithoutGameInput = {
    where: MarketTickWhereUniqueInput
    create: XOR<MarketTickCreateWithoutGameInput, MarketTickUncheckedCreateWithoutGameInput>
  }

  export type MarketTickCreateManyGameInputEnvelope = {
    data: MarketTickCreateManyGameInput | MarketTickCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type PropertyHoldingCreateWithoutGameInput = {
    id?: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutPropertiesInput
    template: PropertyTemplateCreateNestedOneWithoutHoldingsInput
    events?: RepairEventCreateNestedManyWithoutHoldingInput
    refinanceLogs?: RefinanceLogCreateNestedManyWithoutHoldingInput
    listings?: ListingCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingUncheckedCreateWithoutGameInput = {
    id?: string
    playerId: string
    templateId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: RepairEventUncheckedCreateNestedManyWithoutHoldingInput
    refinanceLogs?: RefinanceLogUncheckedCreateNestedManyWithoutHoldingInput
    listings?: ListingUncheckedCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingCreateOrConnectWithoutGameInput = {
    where: PropertyHoldingWhereUniqueInput
    create: XOR<PropertyHoldingCreateWithoutGameInput, PropertyHoldingUncheckedCreateWithoutGameInput>
  }

  export type PropertyHoldingCreateManyGameInputEnvelope = {
    data: PropertyHoldingCreateManyGameInput | PropertyHoldingCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type ListingCreateWithoutGameInput = {
    id?: string
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
    holding?: PropertyHoldingCreateNestedOneWithoutListingsInput
    template?: PropertyTemplateCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutGameInput = {
    id?: string
    holdingId?: string | null
    templateId?: string | null
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
  }

  export type ListingCreateOrConnectWithoutGameInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutGameInput, ListingUncheckedCreateWithoutGameInput>
  }

  export type ListingCreateManyGameInputEnvelope = {
    data: ListingCreateManyGameInput | ListingCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type MarketHoldingCreateWithoutGameInput = {
    id?: string
    symbol: string
    quantity: number
    avgPrice: number
    player: PlayerCreateNestedOneWithoutMarketsInput
  }

  export type MarketHoldingUncheckedCreateWithoutGameInput = {
    id?: string
    playerId: string
    symbol: string
    quantity: number
    avgPrice: number
  }

  export type MarketHoldingCreateOrConnectWithoutGameInput = {
    where: MarketHoldingWhereUniqueInput
    create: XOR<MarketHoldingCreateWithoutGameInput, MarketHoldingUncheckedCreateWithoutGameInput>
  }

  export type MarketHoldingCreateManyGameInputEnvelope = {
    data: MarketHoldingCreateManyGameInput | MarketHoldingCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithWhereUniqueWithoutGameInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutGameInput, PlayerUncheckedUpdateWithoutGameInput>
    create: XOR<PlayerCreateWithoutGameInput, PlayerUncheckedCreateWithoutGameInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutGameInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutGameInput, PlayerUncheckedUpdateWithoutGameInput>
  }

  export type PlayerUpdateManyWithWhereWithoutGameInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutGameInput>
  }

  export type PlayerScalarWhereInput = {
    AND?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    OR?: PlayerScalarWhereInput[]
    NOT?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    id?: StringFilter<"Player"> | string
    nickname?: StringFilter<"Player"> | string
    cash?: FloatFilter<"Player"> | number
    netWorth?: FloatFilter<"Player"> | number
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    gameId?: StringNullableFilter<"Player"> | string | null
    guestId?: StringFilter<"Player"> | string
  }

  export type MarketTickUpsertWithWhereUniqueWithoutGameInput = {
    where: MarketTickWhereUniqueInput
    update: XOR<MarketTickUpdateWithoutGameInput, MarketTickUncheckedUpdateWithoutGameInput>
    create: XOR<MarketTickCreateWithoutGameInput, MarketTickUncheckedCreateWithoutGameInput>
  }

  export type MarketTickUpdateWithWhereUniqueWithoutGameInput = {
    where: MarketTickWhereUniqueInput
    data: XOR<MarketTickUpdateWithoutGameInput, MarketTickUncheckedUpdateWithoutGameInput>
  }

  export type MarketTickUpdateManyWithWhereWithoutGameInput = {
    where: MarketTickScalarWhereInput
    data: XOR<MarketTickUpdateManyMutationInput, MarketTickUncheckedUpdateManyWithoutGameInput>
  }

  export type MarketTickScalarWhereInput = {
    AND?: MarketTickScalarWhereInput | MarketTickScalarWhereInput[]
    OR?: MarketTickScalarWhereInput[]
    NOT?: MarketTickScalarWhereInput | MarketTickScalarWhereInput[]
    id?: StringFilter<"MarketTick"> | string
    gameId?: StringFilter<"MarketTick"> | string
    symbol?: StringFilter<"MarketTick"> | string
    price?: FloatFilter<"MarketTick"> | number
    at?: DateTimeFilter<"MarketTick"> | Date | string
  }

  export type PropertyHoldingUpsertWithWhereUniqueWithoutGameInput = {
    where: PropertyHoldingWhereUniqueInput
    update: XOR<PropertyHoldingUpdateWithoutGameInput, PropertyHoldingUncheckedUpdateWithoutGameInput>
    create: XOR<PropertyHoldingCreateWithoutGameInput, PropertyHoldingUncheckedCreateWithoutGameInput>
  }

  export type PropertyHoldingUpdateWithWhereUniqueWithoutGameInput = {
    where: PropertyHoldingWhereUniqueInput
    data: XOR<PropertyHoldingUpdateWithoutGameInput, PropertyHoldingUncheckedUpdateWithoutGameInput>
  }

  export type PropertyHoldingUpdateManyWithWhereWithoutGameInput = {
    where: PropertyHoldingScalarWhereInput
    data: XOR<PropertyHoldingUpdateManyMutationInput, PropertyHoldingUncheckedUpdateManyWithoutGameInput>
  }

  export type ListingUpsertWithWhereUniqueWithoutGameInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutGameInput, ListingUncheckedUpdateWithoutGameInput>
    create: XOR<ListingCreateWithoutGameInput, ListingUncheckedCreateWithoutGameInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutGameInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutGameInput, ListingUncheckedUpdateWithoutGameInput>
  }

  export type ListingUpdateManyWithWhereWithoutGameInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutGameInput>
  }

  export type ListingScalarWhereInput = {
    AND?: ListingScalarWhereInput | ListingScalarWhereInput[]
    OR?: ListingScalarWhereInput[]
    NOT?: ListingScalarWhereInput | ListingScalarWhereInput[]
    id?: StringFilter<"Listing"> | string
    gameId?: StringFilter<"Listing"> | string
    holdingId?: StringNullableFilter<"Listing"> | string | null
    templateId?: StringNullableFilter<"Listing"> | string | null
    sellerId?: StringNullableFilter<"Listing"> | string | null
    price?: FloatFilter<"Listing"> | number
    type?: StringFilter<"Listing"> | string
    createdAt?: DateTimeFilter<"Listing"> | Date | string
  }

  export type MarketHoldingUpsertWithWhereUniqueWithoutGameInput = {
    where: MarketHoldingWhereUniqueInput
    update: XOR<MarketHoldingUpdateWithoutGameInput, MarketHoldingUncheckedUpdateWithoutGameInput>
    create: XOR<MarketHoldingCreateWithoutGameInput, MarketHoldingUncheckedCreateWithoutGameInput>
  }

  export type MarketHoldingUpdateWithWhereUniqueWithoutGameInput = {
    where: MarketHoldingWhereUniqueInput
    data: XOR<MarketHoldingUpdateWithoutGameInput, MarketHoldingUncheckedUpdateWithoutGameInput>
  }

  export type MarketHoldingUpdateManyWithWhereWithoutGameInput = {
    where: MarketHoldingScalarWhereInput
    data: XOR<MarketHoldingUpdateManyMutationInput, MarketHoldingUncheckedUpdateManyWithoutGameInput>
  }

  export type PropertyHoldingCreateWithoutTemplateInput = {
    id?: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutPropertiesInput
    game: GameCreateNestedOneWithoutPropertyHoldingsInput
    events?: RepairEventCreateNestedManyWithoutHoldingInput
    refinanceLogs?: RefinanceLogCreateNestedManyWithoutHoldingInput
    listings?: ListingCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingUncheckedCreateWithoutTemplateInput = {
    id?: string
    playerId: string
    gameId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: RepairEventUncheckedCreateNestedManyWithoutHoldingInput
    refinanceLogs?: RefinanceLogUncheckedCreateNestedManyWithoutHoldingInput
    listings?: ListingUncheckedCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingCreateOrConnectWithoutTemplateInput = {
    where: PropertyHoldingWhereUniqueInput
    create: XOR<PropertyHoldingCreateWithoutTemplateInput, PropertyHoldingUncheckedCreateWithoutTemplateInput>
  }

  export type PropertyHoldingCreateManyTemplateInputEnvelope = {
    data: PropertyHoldingCreateManyTemplateInput | PropertyHoldingCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ListingCreateWithoutTemplateInput = {
    id?: string
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
    game: GameCreateNestedOneWithoutListingsInput
    holding?: PropertyHoldingCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutTemplateInput = {
    id?: string
    gameId: string
    holdingId?: string | null
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
  }

  export type ListingCreateOrConnectWithoutTemplateInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutTemplateInput, ListingUncheckedCreateWithoutTemplateInput>
  }

  export type ListingCreateManyTemplateInputEnvelope = {
    data: ListingCreateManyTemplateInput | ListingCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type PropertyHoldingUpsertWithWhereUniqueWithoutTemplateInput = {
    where: PropertyHoldingWhereUniqueInput
    update: XOR<PropertyHoldingUpdateWithoutTemplateInput, PropertyHoldingUncheckedUpdateWithoutTemplateInput>
    create: XOR<PropertyHoldingCreateWithoutTemplateInput, PropertyHoldingUncheckedCreateWithoutTemplateInput>
  }

  export type PropertyHoldingUpdateWithWhereUniqueWithoutTemplateInput = {
    where: PropertyHoldingWhereUniqueInput
    data: XOR<PropertyHoldingUpdateWithoutTemplateInput, PropertyHoldingUncheckedUpdateWithoutTemplateInput>
  }

  export type PropertyHoldingUpdateManyWithWhereWithoutTemplateInput = {
    where: PropertyHoldingScalarWhereInput
    data: XOR<PropertyHoldingUpdateManyMutationInput, PropertyHoldingUncheckedUpdateManyWithoutTemplateInput>
  }

  export type ListingUpsertWithWhereUniqueWithoutTemplateInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutTemplateInput, ListingUncheckedUpdateWithoutTemplateInput>
    create: XOR<ListingCreateWithoutTemplateInput, ListingUncheckedCreateWithoutTemplateInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutTemplateInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutTemplateInput, ListingUncheckedUpdateWithoutTemplateInput>
  }

  export type ListingUpdateManyWithWhereWithoutTemplateInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutTemplateInput>
  }

  export type PlayerCreateWithoutPropertiesInput = {
    id?: string
    nickname: string
    cash?: number
    netWorth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    guestId: string
    game?: GameCreateNestedOneWithoutPlayersInput
    markets?: MarketHoldingCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutPropertiesInput = {
    id?: string
    nickname: string
    cash?: number
    netWorth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    gameId?: string | null
    guestId: string
    markets?: MarketHoldingUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutPropertiesInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPropertiesInput, PlayerUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyTemplateCreateWithoutHoldingsInput = {
    id?: string
    name: string
    city: string
    imageUrl: string
    price: number
    baseRent: number
    taxes: number
    insurance: number
    maintenance: number
    listings?: ListingCreateNestedManyWithoutTemplateInput
  }

  export type PropertyTemplateUncheckedCreateWithoutHoldingsInput = {
    id?: string
    name: string
    city: string
    imageUrl: string
    price: number
    baseRent: number
    taxes: number
    insurance: number
    maintenance: number
    listings?: ListingUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type PropertyTemplateCreateOrConnectWithoutHoldingsInput = {
    where: PropertyTemplateWhereUniqueInput
    create: XOR<PropertyTemplateCreateWithoutHoldingsInput, PropertyTemplateUncheckedCreateWithoutHoldingsInput>
  }

  export type GameCreateWithoutPropertyHoldingsInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    players?: PlayerCreateNestedManyWithoutGameInput
    marketTicks?: MarketTickCreateNestedManyWithoutGameInput
    listings?: ListingCreateNestedManyWithoutGameInput
    marketHoldings?: MarketHoldingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutPropertyHoldingsInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    players?: PlayerUncheckedCreateNestedManyWithoutGameInput
    marketTicks?: MarketTickUncheckedCreateNestedManyWithoutGameInput
    listings?: ListingUncheckedCreateNestedManyWithoutGameInput
    marketHoldings?: MarketHoldingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutPropertyHoldingsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutPropertyHoldingsInput, GameUncheckedCreateWithoutPropertyHoldingsInput>
  }

  export type RepairEventCreateWithoutHoldingInput = {
    id?: string
    type: string
    cost: number
    impact: string
    createdAt?: Date | string
  }

  export type RepairEventUncheckedCreateWithoutHoldingInput = {
    id?: string
    type: string
    cost: number
    impact: string
    createdAt?: Date | string
  }

  export type RepairEventCreateOrConnectWithoutHoldingInput = {
    where: RepairEventWhereUniqueInput
    create: XOR<RepairEventCreateWithoutHoldingInput, RepairEventUncheckedCreateWithoutHoldingInput>
  }

  export type RepairEventCreateManyHoldingInputEnvelope = {
    data: RepairEventCreateManyHoldingInput | RepairEventCreateManyHoldingInput[]
    skipDuplicates?: boolean
  }

  export type RefinanceLogCreateWithoutHoldingInput = {
    id?: string
    amount: number
    rate: number
    at?: Date | string
  }

  export type RefinanceLogUncheckedCreateWithoutHoldingInput = {
    id?: string
    amount: number
    rate: number
    at?: Date | string
  }

  export type RefinanceLogCreateOrConnectWithoutHoldingInput = {
    where: RefinanceLogWhereUniqueInput
    create: XOR<RefinanceLogCreateWithoutHoldingInput, RefinanceLogUncheckedCreateWithoutHoldingInput>
  }

  export type RefinanceLogCreateManyHoldingInputEnvelope = {
    data: RefinanceLogCreateManyHoldingInput | RefinanceLogCreateManyHoldingInput[]
    skipDuplicates?: boolean
  }

  export type ListingCreateWithoutHoldingInput = {
    id?: string
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
    game: GameCreateNestedOneWithoutListingsInput
    template?: PropertyTemplateCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutHoldingInput = {
    id?: string
    gameId: string
    templateId?: string | null
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
  }

  export type ListingCreateOrConnectWithoutHoldingInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutHoldingInput, ListingUncheckedCreateWithoutHoldingInput>
  }

  export type ListingCreateManyHoldingInputEnvelope = {
    data: ListingCreateManyHoldingInput | ListingCreateManyHoldingInput[]
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithoutPropertiesInput = {
    update: XOR<PlayerUpdateWithoutPropertiesInput, PlayerUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PlayerCreateWithoutPropertiesInput, PlayerUncheckedCreateWithoutPropertiesInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutPropertiesInput, PlayerUncheckedUpdateWithoutPropertiesInput>
  }

  export type PlayerUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: StringFieldUpdateOperationsInput | string
    game?: GameUpdateOneWithoutPlayersNestedInput
    markets?: MarketHoldingUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: StringFieldUpdateOperationsInput | string
    markets?: MarketHoldingUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PropertyTemplateUpsertWithoutHoldingsInput = {
    update: XOR<PropertyTemplateUpdateWithoutHoldingsInput, PropertyTemplateUncheckedUpdateWithoutHoldingsInput>
    create: XOR<PropertyTemplateCreateWithoutHoldingsInput, PropertyTemplateUncheckedCreateWithoutHoldingsInput>
    where?: PropertyTemplateWhereInput
  }

  export type PropertyTemplateUpdateToOneWithWhereWithoutHoldingsInput = {
    where?: PropertyTemplateWhereInput
    data: XOR<PropertyTemplateUpdateWithoutHoldingsInput, PropertyTemplateUncheckedUpdateWithoutHoldingsInput>
  }

  export type PropertyTemplateUpdateWithoutHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    baseRent?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    maintenance?: FloatFieldUpdateOperationsInput | number
    listings?: ListingUpdateManyWithoutTemplateNestedInput
  }

  export type PropertyTemplateUncheckedUpdateWithoutHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    baseRent?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    maintenance?: FloatFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type GameUpsertWithoutPropertyHoldingsInput = {
    update: XOR<GameUpdateWithoutPropertyHoldingsInput, GameUncheckedUpdateWithoutPropertyHoldingsInput>
    create: XOR<GameCreateWithoutPropertyHoldingsInput, GameUncheckedCreateWithoutPropertyHoldingsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutPropertyHoldingsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutPropertyHoldingsInput, GameUncheckedUpdateWithoutPropertyHoldingsInput>
  }

  export type GameUpdateWithoutPropertyHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUpdateManyWithoutGameNestedInput
    marketTicks?: MarketTickUpdateManyWithoutGameNestedInput
    listings?: ListingUpdateManyWithoutGameNestedInput
    marketHoldings?: MarketHoldingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutPropertyHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUncheckedUpdateManyWithoutGameNestedInput
    marketTicks?: MarketTickUncheckedUpdateManyWithoutGameNestedInput
    listings?: ListingUncheckedUpdateManyWithoutGameNestedInput
    marketHoldings?: MarketHoldingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type RepairEventUpsertWithWhereUniqueWithoutHoldingInput = {
    where: RepairEventWhereUniqueInput
    update: XOR<RepairEventUpdateWithoutHoldingInput, RepairEventUncheckedUpdateWithoutHoldingInput>
    create: XOR<RepairEventCreateWithoutHoldingInput, RepairEventUncheckedCreateWithoutHoldingInput>
  }

  export type RepairEventUpdateWithWhereUniqueWithoutHoldingInput = {
    where: RepairEventWhereUniqueInput
    data: XOR<RepairEventUpdateWithoutHoldingInput, RepairEventUncheckedUpdateWithoutHoldingInput>
  }

  export type RepairEventUpdateManyWithWhereWithoutHoldingInput = {
    where: RepairEventScalarWhereInput
    data: XOR<RepairEventUpdateManyMutationInput, RepairEventUncheckedUpdateManyWithoutHoldingInput>
  }

  export type RepairEventScalarWhereInput = {
    AND?: RepairEventScalarWhereInput | RepairEventScalarWhereInput[]
    OR?: RepairEventScalarWhereInput[]
    NOT?: RepairEventScalarWhereInput | RepairEventScalarWhereInput[]
    id?: StringFilter<"RepairEvent"> | string
    holdingId?: StringFilter<"RepairEvent"> | string
    type?: StringFilter<"RepairEvent"> | string
    cost?: FloatFilter<"RepairEvent"> | number
    impact?: StringFilter<"RepairEvent"> | string
    createdAt?: DateTimeFilter<"RepairEvent"> | Date | string
  }

  export type RefinanceLogUpsertWithWhereUniqueWithoutHoldingInput = {
    where: RefinanceLogWhereUniqueInput
    update: XOR<RefinanceLogUpdateWithoutHoldingInput, RefinanceLogUncheckedUpdateWithoutHoldingInput>
    create: XOR<RefinanceLogCreateWithoutHoldingInput, RefinanceLogUncheckedCreateWithoutHoldingInput>
  }

  export type RefinanceLogUpdateWithWhereUniqueWithoutHoldingInput = {
    where: RefinanceLogWhereUniqueInput
    data: XOR<RefinanceLogUpdateWithoutHoldingInput, RefinanceLogUncheckedUpdateWithoutHoldingInput>
  }

  export type RefinanceLogUpdateManyWithWhereWithoutHoldingInput = {
    where: RefinanceLogScalarWhereInput
    data: XOR<RefinanceLogUpdateManyMutationInput, RefinanceLogUncheckedUpdateManyWithoutHoldingInput>
  }

  export type RefinanceLogScalarWhereInput = {
    AND?: RefinanceLogScalarWhereInput | RefinanceLogScalarWhereInput[]
    OR?: RefinanceLogScalarWhereInput[]
    NOT?: RefinanceLogScalarWhereInput | RefinanceLogScalarWhereInput[]
    id?: StringFilter<"RefinanceLog"> | string
    holdingId?: StringFilter<"RefinanceLog"> | string
    amount?: FloatFilter<"RefinanceLog"> | number
    rate?: FloatFilter<"RefinanceLog"> | number
    at?: DateTimeFilter<"RefinanceLog"> | Date | string
  }

  export type ListingUpsertWithWhereUniqueWithoutHoldingInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutHoldingInput, ListingUncheckedUpdateWithoutHoldingInput>
    create: XOR<ListingCreateWithoutHoldingInput, ListingUncheckedCreateWithoutHoldingInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutHoldingInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutHoldingInput, ListingUncheckedUpdateWithoutHoldingInput>
  }

  export type ListingUpdateManyWithWhereWithoutHoldingInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutHoldingInput>
  }

  export type PropertyHoldingCreateWithoutEventsInput = {
    id?: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutPropertiesInput
    template: PropertyTemplateCreateNestedOneWithoutHoldingsInput
    game: GameCreateNestedOneWithoutPropertyHoldingsInput
    refinanceLogs?: RefinanceLogCreateNestedManyWithoutHoldingInput
    listings?: ListingCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingUncheckedCreateWithoutEventsInput = {
    id?: string
    playerId: string
    templateId: string
    gameId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    refinanceLogs?: RefinanceLogUncheckedCreateNestedManyWithoutHoldingInput
    listings?: ListingUncheckedCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingCreateOrConnectWithoutEventsInput = {
    where: PropertyHoldingWhereUniqueInput
    create: XOR<PropertyHoldingCreateWithoutEventsInput, PropertyHoldingUncheckedCreateWithoutEventsInput>
  }

  export type PropertyHoldingUpsertWithoutEventsInput = {
    update: XOR<PropertyHoldingUpdateWithoutEventsInput, PropertyHoldingUncheckedUpdateWithoutEventsInput>
    create: XOR<PropertyHoldingCreateWithoutEventsInput, PropertyHoldingUncheckedCreateWithoutEventsInput>
    where?: PropertyHoldingWhereInput
  }

  export type PropertyHoldingUpdateToOneWithWhereWithoutEventsInput = {
    where?: PropertyHoldingWhereInput
    data: XOR<PropertyHoldingUpdateWithoutEventsInput, PropertyHoldingUncheckedUpdateWithoutEventsInput>
  }

  export type PropertyHoldingUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPropertiesNestedInput
    template?: PropertyTemplateUpdateOneRequiredWithoutHoldingsNestedInput
    game?: GameUpdateOneRequiredWithoutPropertyHoldingsNestedInput
    refinanceLogs?: RefinanceLogUpdateManyWithoutHoldingNestedInput
    listings?: ListingUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refinanceLogs?: RefinanceLogUncheckedUpdateManyWithoutHoldingNestedInput
    listings?: ListingUncheckedUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingCreateWithoutRefinanceLogsInput = {
    id?: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutPropertiesInput
    template: PropertyTemplateCreateNestedOneWithoutHoldingsInput
    game: GameCreateNestedOneWithoutPropertyHoldingsInput
    events?: RepairEventCreateNestedManyWithoutHoldingInput
    listings?: ListingCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingUncheckedCreateWithoutRefinanceLogsInput = {
    id?: string
    playerId: string
    templateId: string
    gameId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: RepairEventUncheckedCreateNestedManyWithoutHoldingInput
    listings?: ListingUncheckedCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingCreateOrConnectWithoutRefinanceLogsInput = {
    where: PropertyHoldingWhereUniqueInput
    create: XOR<PropertyHoldingCreateWithoutRefinanceLogsInput, PropertyHoldingUncheckedCreateWithoutRefinanceLogsInput>
  }

  export type PropertyHoldingUpsertWithoutRefinanceLogsInput = {
    update: XOR<PropertyHoldingUpdateWithoutRefinanceLogsInput, PropertyHoldingUncheckedUpdateWithoutRefinanceLogsInput>
    create: XOR<PropertyHoldingCreateWithoutRefinanceLogsInput, PropertyHoldingUncheckedCreateWithoutRefinanceLogsInput>
    where?: PropertyHoldingWhereInput
  }

  export type PropertyHoldingUpdateToOneWithWhereWithoutRefinanceLogsInput = {
    where?: PropertyHoldingWhereInput
    data: XOR<PropertyHoldingUpdateWithoutRefinanceLogsInput, PropertyHoldingUncheckedUpdateWithoutRefinanceLogsInput>
  }

  export type PropertyHoldingUpdateWithoutRefinanceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPropertiesNestedInput
    template?: PropertyTemplateUpdateOneRequiredWithoutHoldingsNestedInput
    game?: GameUpdateOneRequiredWithoutPropertyHoldingsNestedInput
    events?: RepairEventUpdateManyWithoutHoldingNestedInput
    listings?: ListingUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingUncheckedUpdateWithoutRefinanceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: RepairEventUncheckedUpdateManyWithoutHoldingNestedInput
    listings?: ListingUncheckedUpdateManyWithoutHoldingNestedInput
  }

  export type GameCreateWithoutListingsInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    players?: PlayerCreateNestedManyWithoutGameInput
    marketTicks?: MarketTickCreateNestedManyWithoutGameInput
    propertyHoldings?: PropertyHoldingCreateNestedManyWithoutGameInput
    marketHoldings?: MarketHoldingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutListingsInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    players?: PlayerUncheckedCreateNestedManyWithoutGameInput
    marketTicks?: MarketTickUncheckedCreateNestedManyWithoutGameInput
    propertyHoldings?: PropertyHoldingUncheckedCreateNestedManyWithoutGameInput
    marketHoldings?: MarketHoldingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutListingsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutListingsInput, GameUncheckedCreateWithoutListingsInput>
  }

  export type PropertyHoldingCreateWithoutListingsInput = {
    id?: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutPropertiesInput
    template: PropertyTemplateCreateNestedOneWithoutHoldingsInput
    game: GameCreateNestedOneWithoutPropertyHoldingsInput
    events?: RepairEventCreateNestedManyWithoutHoldingInput
    refinanceLogs?: RefinanceLogCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingUncheckedCreateWithoutListingsInput = {
    id?: string
    playerId: string
    templateId: string
    gameId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: RepairEventUncheckedCreateNestedManyWithoutHoldingInput
    refinanceLogs?: RefinanceLogUncheckedCreateNestedManyWithoutHoldingInput
  }

  export type PropertyHoldingCreateOrConnectWithoutListingsInput = {
    where: PropertyHoldingWhereUniqueInput
    create: XOR<PropertyHoldingCreateWithoutListingsInput, PropertyHoldingUncheckedCreateWithoutListingsInput>
  }

  export type PropertyTemplateCreateWithoutListingsInput = {
    id?: string
    name: string
    city: string
    imageUrl: string
    price: number
    baseRent: number
    taxes: number
    insurance: number
    maintenance: number
    holdings?: PropertyHoldingCreateNestedManyWithoutTemplateInput
  }

  export type PropertyTemplateUncheckedCreateWithoutListingsInput = {
    id?: string
    name: string
    city: string
    imageUrl: string
    price: number
    baseRent: number
    taxes: number
    insurance: number
    maintenance: number
    holdings?: PropertyHoldingUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type PropertyTemplateCreateOrConnectWithoutListingsInput = {
    where: PropertyTemplateWhereUniqueInput
    create: XOR<PropertyTemplateCreateWithoutListingsInput, PropertyTemplateUncheckedCreateWithoutListingsInput>
  }

  export type GameUpsertWithoutListingsInput = {
    update: XOR<GameUpdateWithoutListingsInput, GameUncheckedUpdateWithoutListingsInput>
    create: XOR<GameCreateWithoutListingsInput, GameUncheckedCreateWithoutListingsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutListingsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutListingsInput, GameUncheckedUpdateWithoutListingsInput>
  }

  export type GameUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUpdateManyWithoutGameNestedInput
    marketTicks?: MarketTickUpdateManyWithoutGameNestedInput
    propertyHoldings?: PropertyHoldingUpdateManyWithoutGameNestedInput
    marketHoldings?: MarketHoldingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUncheckedUpdateManyWithoutGameNestedInput
    marketTicks?: MarketTickUncheckedUpdateManyWithoutGameNestedInput
    propertyHoldings?: PropertyHoldingUncheckedUpdateManyWithoutGameNestedInput
    marketHoldings?: MarketHoldingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type PropertyHoldingUpsertWithoutListingsInput = {
    update: XOR<PropertyHoldingUpdateWithoutListingsInput, PropertyHoldingUncheckedUpdateWithoutListingsInput>
    create: XOR<PropertyHoldingCreateWithoutListingsInput, PropertyHoldingUncheckedCreateWithoutListingsInput>
    where?: PropertyHoldingWhereInput
  }

  export type PropertyHoldingUpdateToOneWithWhereWithoutListingsInput = {
    where?: PropertyHoldingWhereInput
    data: XOR<PropertyHoldingUpdateWithoutListingsInput, PropertyHoldingUncheckedUpdateWithoutListingsInput>
  }

  export type PropertyHoldingUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPropertiesNestedInput
    template?: PropertyTemplateUpdateOneRequiredWithoutHoldingsNestedInput
    game?: GameUpdateOneRequiredWithoutPropertyHoldingsNestedInput
    events?: RepairEventUpdateManyWithoutHoldingNestedInput
    refinanceLogs?: RefinanceLogUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: RepairEventUncheckedUpdateManyWithoutHoldingNestedInput
    refinanceLogs?: RefinanceLogUncheckedUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyTemplateUpsertWithoutListingsInput = {
    update: XOR<PropertyTemplateUpdateWithoutListingsInput, PropertyTemplateUncheckedUpdateWithoutListingsInput>
    create: XOR<PropertyTemplateCreateWithoutListingsInput, PropertyTemplateUncheckedCreateWithoutListingsInput>
    where?: PropertyTemplateWhereInput
  }

  export type PropertyTemplateUpdateToOneWithWhereWithoutListingsInput = {
    where?: PropertyTemplateWhereInput
    data: XOR<PropertyTemplateUpdateWithoutListingsInput, PropertyTemplateUncheckedUpdateWithoutListingsInput>
  }

  export type PropertyTemplateUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    baseRent?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    maintenance?: FloatFieldUpdateOperationsInput | number
    holdings?: PropertyHoldingUpdateManyWithoutTemplateNestedInput
  }

  export type PropertyTemplateUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    baseRent?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    insurance?: FloatFieldUpdateOperationsInput | number
    maintenance?: FloatFieldUpdateOperationsInput | number
    holdings?: PropertyHoldingUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type PlayerCreateWithoutMarketsInput = {
    id?: string
    nickname: string
    cash?: number
    netWorth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    guestId: string
    game?: GameCreateNestedOneWithoutPlayersInput
    properties?: PropertyHoldingCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutMarketsInput = {
    id?: string
    nickname: string
    cash?: number
    netWorth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    gameId?: string | null
    guestId: string
    properties?: PropertyHoldingUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutMarketsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMarketsInput, PlayerUncheckedCreateWithoutMarketsInput>
  }

  export type GameCreateWithoutMarketHoldingsInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    players?: PlayerCreateNestedManyWithoutGameInput
    marketTicks?: MarketTickCreateNestedManyWithoutGameInput
    propertyHoldings?: PropertyHoldingCreateNestedManyWithoutGameInput
    listings?: ListingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutMarketHoldingsInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    players?: PlayerUncheckedCreateNestedManyWithoutGameInput
    marketTicks?: MarketTickUncheckedCreateNestedManyWithoutGameInput
    propertyHoldings?: PropertyHoldingUncheckedCreateNestedManyWithoutGameInput
    listings?: ListingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutMarketHoldingsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutMarketHoldingsInput, GameUncheckedCreateWithoutMarketHoldingsInput>
  }

  export type PlayerUpsertWithoutMarketsInput = {
    update: XOR<PlayerUpdateWithoutMarketsInput, PlayerUncheckedUpdateWithoutMarketsInput>
    create: XOR<PlayerCreateWithoutMarketsInput, PlayerUncheckedCreateWithoutMarketsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutMarketsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutMarketsInput, PlayerUncheckedUpdateWithoutMarketsInput>
  }

  export type PlayerUpdateWithoutMarketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: StringFieldUpdateOperationsInput | string
    game?: GameUpdateOneWithoutPlayersNestedInput
    properties?: PropertyHoldingUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMarketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyHoldingUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type GameUpsertWithoutMarketHoldingsInput = {
    update: XOR<GameUpdateWithoutMarketHoldingsInput, GameUncheckedUpdateWithoutMarketHoldingsInput>
    create: XOR<GameCreateWithoutMarketHoldingsInput, GameUncheckedCreateWithoutMarketHoldingsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutMarketHoldingsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutMarketHoldingsInput, GameUncheckedUpdateWithoutMarketHoldingsInput>
  }

  export type GameUpdateWithoutMarketHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUpdateManyWithoutGameNestedInput
    marketTicks?: MarketTickUpdateManyWithoutGameNestedInput
    propertyHoldings?: PropertyHoldingUpdateManyWithoutGameNestedInput
    listings?: ListingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutMarketHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUncheckedUpdateManyWithoutGameNestedInput
    marketTicks?: MarketTickUncheckedUpdateManyWithoutGameNestedInput
    propertyHoldings?: PropertyHoldingUncheckedUpdateManyWithoutGameNestedInput
    listings?: ListingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateWithoutMarketTicksInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    players?: PlayerCreateNestedManyWithoutGameInput
    propertyHoldings?: PropertyHoldingCreateNestedManyWithoutGameInput
    listings?: ListingCreateNestedManyWithoutGameInput
    marketHoldings?: MarketHoldingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutMarketTicksInput = {
    id?: string
    code: string
    status?: string
    createdAt?: Date | string
    startedAt?: Date | string | null
    updatedAt?: Date | string
    players?: PlayerUncheckedCreateNestedManyWithoutGameInput
    propertyHoldings?: PropertyHoldingUncheckedCreateNestedManyWithoutGameInput
    listings?: ListingUncheckedCreateNestedManyWithoutGameInput
    marketHoldings?: MarketHoldingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutMarketTicksInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutMarketTicksInput, GameUncheckedCreateWithoutMarketTicksInput>
  }

  export type GameUpsertWithoutMarketTicksInput = {
    update: XOR<GameUpdateWithoutMarketTicksInput, GameUncheckedUpdateWithoutMarketTicksInput>
    create: XOR<GameCreateWithoutMarketTicksInput, GameUncheckedCreateWithoutMarketTicksInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutMarketTicksInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutMarketTicksInput, GameUncheckedUpdateWithoutMarketTicksInput>
  }

  export type GameUpdateWithoutMarketTicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUpdateManyWithoutGameNestedInput
    propertyHoldings?: PropertyHoldingUpdateManyWithoutGameNestedInput
    listings?: ListingUpdateManyWithoutGameNestedInput
    marketHoldings?: MarketHoldingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutMarketTicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUncheckedUpdateManyWithoutGameNestedInput
    propertyHoldings?: PropertyHoldingUncheckedUpdateManyWithoutGameNestedInput
    listings?: ListingUncheckedUpdateManyWithoutGameNestedInput
    marketHoldings?: MarketHoldingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type PropertyHoldingCreateManyPlayerInput = {
    id?: string
    templateId: string
    gameId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketHoldingCreateManyPlayerInput = {
    id?: string
    gameId: string
    symbol: string
    quantity: number
    avgPrice: number
  }

  export type PropertyHoldingUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: PropertyTemplateUpdateOneRequiredWithoutHoldingsNestedInput
    game?: GameUpdateOneRequiredWithoutPropertyHoldingsNestedInput
    events?: RepairEventUpdateManyWithoutHoldingNestedInput
    refinanceLogs?: RefinanceLogUpdateManyWithoutHoldingNestedInput
    listings?: ListingUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: RepairEventUncheckedUpdateManyWithoutHoldingNestedInput
    refinanceLogs?: RefinanceLogUncheckedUpdateManyWithoutHoldingNestedInput
    listings?: ListingUncheckedUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketHoldingUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    avgPrice?: FloatFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutMarketHoldingsNestedInput
  }

  export type MarketHoldingUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    avgPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type MarketHoldingUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    avgPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type PlayerCreateManyGameInput = {
    id?: string
    nickname: string
    cash?: number
    netWorth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    guestId: string
  }

  export type MarketTickCreateManyGameInput = {
    id?: string
    symbol: string
    price: number
    at?: Date | string
  }

  export type PropertyHoldingCreateManyGameInput = {
    id?: string
    playerId: string
    templateId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListingCreateManyGameInput = {
    id?: string
    holdingId?: string | null
    templateId?: string | null
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
  }

  export type MarketHoldingCreateManyGameInput = {
    id?: string
    playerId: string
    symbol: string
    quantity: number
    avgPrice: number
  }

  export type PlayerUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyHoldingUpdateManyWithoutPlayerNestedInput
    markets?: MarketHoldingUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyHoldingUncheckedUpdateManyWithoutPlayerNestedInput
    markets?: MarketHoldingUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    cash?: FloatFieldUpdateOperationsInput | number
    netWorth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: StringFieldUpdateOperationsInput | string
  }

  export type MarketTickUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTickUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTickUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyHoldingUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPropertiesNestedInput
    template?: PropertyTemplateUpdateOneRequiredWithoutHoldingsNestedInput
    events?: RepairEventUpdateManyWithoutHoldingNestedInput
    refinanceLogs?: RefinanceLogUpdateManyWithoutHoldingNestedInput
    listings?: ListingUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: RepairEventUncheckedUpdateManyWithoutHoldingNestedInput
    refinanceLogs?: RefinanceLogUncheckedUpdateManyWithoutHoldingNestedInput
    listings?: ListingUncheckedUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holding?: PropertyHoldingUpdateOneWithoutListingsNestedInput
    template?: PropertyTemplateUpdateOneWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    holdingId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    holdingId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketHoldingUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    avgPrice?: FloatFieldUpdateOperationsInput | number
    player?: PlayerUpdateOneRequiredWithoutMarketsNestedInput
  }

  export type MarketHoldingUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    avgPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type MarketHoldingUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    avgPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type PropertyHoldingCreateManyTemplateInput = {
    id?: string
    playerId: string
    gameId: string
    purchasePrice: number
    currentValue: number
    currentRent: number
    mortgageRate?: number
    mortgageDebt?: number
    weeklyPayment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListingCreateManyTemplateInput = {
    id?: string
    gameId: string
    holdingId?: string | null
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
  }

  export type PropertyHoldingUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPropertiesNestedInput
    game?: GameUpdateOneRequiredWithoutPropertyHoldingsNestedInput
    events?: RepairEventUpdateManyWithoutHoldingNestedInput
    refinanceLogs?: RefinanceLogUpdateManyWithoutHoldingNestedInput
    listings?: ListingUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: RepairEventUncheckedUpdateManyWithoutHoldingNestedInput
    refinanceLogs?: RefinanceLogUncheckedUpdateManyWithoutHoldingNestedInput
    listings?: ListingUncheckedUpdateManyWithoutHoldingNestedInput
  }

  export type PropertyHoldingUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    currentRent?: FloatFieldUpdateOperationsInput | number
    mortgageRate?: FloatFieldUpdateOperationsInput | number
    mortgageDebt?: FloatFieldUpdateOperationsInput | number
    weeklyPayment?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutListingsNestedInput
    holding?: PropertyHoldingUpdateOneWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    holdingId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    holdingId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairEventCreateManyHoldingInput = {
    id?: string
    type: string
    cost: number
    impact: string
    createdAt?: Date | string
  }

  export type RefinanceLogCreateManyHoldingInput = {
    id?: string
    amount: number
    rate: number
    at?: Date | string
  }

  export type ListingCreateManyHoldingInput = {
    id?: string
    gameId: string
    templateId?: string | null
    sellerId?: string | null
    price: number
    type: string
    createdAt?: Date | string
  }

  export type RepairEventUpdateWithoutHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairEventUncheckedUpdateWithoutHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairEventUncheckedUpdateManyWithoutHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefinanceLogUpdateWithoutHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefinanceLogUncheckedUpdateWithoutHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefinanceLogUncheckedUpdateManyWithoutHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUpdateWithoutHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutListingsNestedInput
    template?: PropertyTemplateUpdateOneWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUncheckedUpdateManyWithoutHoldingInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use PlayerCountOutputTypeDefaultArgs instead
     */
    export type PlayerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameCountOutputTypeDefaultArgs instead
     */
    export type GameCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyTemplateCountOutputTypeDefaultArgs instead
     */
    export type PropertyTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyHoldingCountOutputTypeDefaultArgs instead
     */
    export type PropertyHoldingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyHoldingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerDefaultArgs instead
     */
    export type PlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameDefaultArgs instead
     */
    export type GameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyTemplateDefaultArgs instead
     */
    export type PropertyTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyHoldingDefaultArgs instead
     */
    export type PropertyHoldingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyHoldingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RepairEventDefaultArgs instead
     */
    export type RepairEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RepairEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefinanceLogDefaultArgs instead
     */
    export type RefinanceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefinanceLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ListingDefaultArgs instead
     */
    export type ListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ListingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketHoldingDefaultArgs instead
     */
    export type MarketHoldingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketHoldingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketTickDefaultArgs instead
     */
    export type MarketTickArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketTickDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}