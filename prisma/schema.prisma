// Prisma schema for Héritier Millionnaire
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  isAdmin      Boolean  @default(false)
  emailVerified Boolean @default(false)
  createdAt    DateTime @default(now())
  resetTokens  PasswordResetToken[]
  verifyTokens EmailVerificationToken[]
}

model Player {
  id        String   @id @default(cuid())
  nickname  String
  cash      Float    @default(1000000)
  netWorth  Float    @default(1000000)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Système de tokens pour le quiz
  quizTokens Int      @default(1) // Nombre de tokens disponibles pour jouer au quiz
  lastTokenEarnedAt DateTime @default(now()) // Dernière fois qu'un token a été gagné

  game   Game?   @relation(fields: [gameId], references: [id])
  gameId String?

  // Identifiant invité associé au cookie côté client pour cette partie
  guestId String

  properties PropertyHolding[]
  markets    MarketHolding[]
  dividendLogs DividendLog[]
  quizSessions QuizSession[]
  quizQuestionsSeen QuizQuestionSeen[]
  prizesWon Prize[] @relation("PrizeWinner")

  // Parrainage / Invitations
  sentInvites      ReferralInvite[] @relation("Inviter")
  acceptedInvites  ReferralInvite[] @relation("Invitee")

  @@unique([gameId, guestId])
  @@unique([gameId, nickname])
}

model Game {
  id        String   @id @default(cuid())
  code      String   @unique
  status    String   @default("lobby") // lobby | running | ended
  createdAt DateTime @default(now())
  startedAt DateTime?
  updatedAt DateTime @updatedAt

  // Paramètres économiques pilotés par le jeu
  baseMortgageRate   Float   @default(0.05) // 5% au départ, varie de 0.25%/mois entre 2% et 7%
  appreciationAnnual Float   @default(0.03) // 3% par défaut, choisie chaque année entre 2% et 5%
  // Inflation générale appliquée aux nouveaux prix (1% à 5% l'an) et index cumulatif
  inflationAnnual    Float   @default(0.02) // choisi au démarrage de la partie (1% à 5%)
  inflationIndex     Float   @default(1)    // multiplicateur cumulé, part de 1 et augmente chaque "semaine" (tick horaire)

  players     Player[]
  marketTicks MarketTick[]
  propertyHoldings PropertyHolding[]
  listings    Listing[]
  marketHoldings MarketHolding[]
  dividendLogs DividendLog[]
  quizSessions QuizSession[]
  referralInvites ReferralInvite[]
}

model PropertyTemplate {
  id         String  @id @default(cuid())
  name       String
  city       String
  imageUrl   String
  description String  @default("")
  price      Float
  baseRent   Float
  taxes      Float
  insurance  Float
  maintenance Float
  // Nouvelles méta-infos réalisme (QC)
  units       Int     @default(1)   // nombre de logements
  plumbingState   String @default("bon") // bon | moyen | à rénover
  electricityState String @default("bon")
  roofState       String @default("bon")
  floors          Int     @default(1)
  hasCommercialCenter Boolean @default(false)

  holdings   PropertyHolding[]
  listings   Listing[]
}

model PropertyHolding {
  id           String   @id @default(cuid())
  player       Player   @relation(fields: [playerId], references: [id])
  playerId     String
  template     PropertyTemplate @relation(fields: [templateId], references: [id])
  templateId   String
  game         Game     @relation(fields: [gameId], references: [id])
  gameId       String
  purchasePrice Float
  // Mise de fonds au moment de l'achat (pour bilan)
  downPayment   Float   @default(0)
  // Dette initiale contractée à l'achat (purchasePrice - downPayment)
  initialMortgageDebt Float @default(0)
  currentValue  Float
  currentRent   Float
  mortgageRate  Float   @default(0.05)
  mortgageDebt  Float   @default(0)
  weeklyPayment Float   @default(0)
  weeksElapsed  Int     @default(0)
  termYears     Int     @default(25)
  // Suivis cumulés depuis l'achat
  accumulatedRent            Float @default(0)
  accumulatedInterestPaid    Float @default(0)
  accumulatedTaxesPaid       Float @default(0)
  accumulatedInsurancePaid   Float @default(0)
  accumulatedMaintenancePaid Float @default(0)
  accumulatedNetCashflow     Float @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  events RepairEvent[]
  refinanceLogs RefinanceLog[]
  listings Listing[]
}

model RepairEvent {
  id         String   @id @default(cuid())
  holding    PropertyHolding @relation(fields: [holdingId], references: [id])
  holdingId  String
  type       String // minor_break | major_break | renovation | bonus
  cost       Float
  impact     String // free text or JSON later
  createdAt  DateTime @default(now())
}

model RefinanceLog {
  id        String   @id @default(cuid())
  holding   PropertyHolding @relation(fields: [holdingId], references: [id])
  holdingId String
  amount    Float
  rate      Float
  at        DateTime @default(now())
}

model Listing {
  id          String   @id @default(cuid())
  game        Game     @relation(fields: [gameId], references: [id])
  gameId      String
  holding     PropertyHolding? @relation(fields: [holdingId], references: [id])
  holdingId   String?
  template    PropertyTemplate? @relation(fields: [templateId], references: [id])
  templateId  String?
  sellerId    String?
  price       Float
  type        String // fixed | auction
  createdAt   DateTime @default(now())
}

model MarketHolding {
  id        String  @id @default(cuid())
  player    Player  @relation(fields: [playerId], references: [id])
  playerId  String
  game      Game    @relation(fields: [gameId], references: [id])
  gameId    String
  symbol    String
  quantity  Float
  avgPrice  Float

  @@unique([playerId, gameId, symbol])
}

model MarketTick {
  id       String  @id @default(cuid())
  game     Game    @relation(fields: [gameId], references: [id])
  gameId   String
  symbol   String
  price    Float
  at       DateTime @default(now())
}

model DividendLog {
  id        String   @id @default(cuid())
  game      Game     @relation(fields: [gameId], references: [id])
  gameId    String
  player    Player   @relation(fields: [playerId], references: [id])
  playerId  String
  symbol    String
  amount    Float
  at        DateTime @default(now())
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())
}

// === QUIZ "Quitte ou Double" ===

model QuizQuestion {
  id          String   @id @default(cuid())
  question    String
  optionA     String
  optionB     String
  optionC     String
  optionD     String
  correctAnswer String  // 'A', 'B', 'C', ou 'D'
  difficulty  String   // 'easy', 'medium', 'hard'
  category    String   // 'finance', 'economy', 'real-estate', 'business', 'technology', 'science', 'history', 'geography', 'sports', 'arts', 'cinema', 'music', 'literature', 'culture', 'nature', 'health', 'food', 'general'
  imageUrl    String?  // URL optionnelle d'une image illustrant la question
  createdAt   DateTime @default(now())
  
  attempts    QuizAttempt[]
  seenByPlayers QuizQuestionSeen[]
}

// Table de suivi des questions déjà vues par chaque joueur
model QuizQuestionSeen {
  id          String   @id @default(cuid())
  player      Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  playerId    String
  question    QuizQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId  String
  seenAt      DateTime @default(now())
  
  @@unique([playerId, questionId]) // Un joueur ne peut voir qu'une fois chaque question
  @@index([playerId])
}

model Prize {
  id          String   @id @default(cuid())
  type        String   // e.g. "amazon-gift-card"
  amountValue Int      // Montant en dollars
  currency    String   @default("CAD")
  awardedAt   DateTime
  winnerId    String?
  winnerEmail String?  // Sauvegarde email si disponible
  gameId      String?   // Contexte de partie si pertinent
  notes       String?   // Détails (ex: netWorth du gagnant, classement)
  player      Player?   @relation("PrizeWinner", fields: [winnerId], references: [id])
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now()) @updatedAt
}

model QuizSession {
  id              String   @id @default(cuid())
  player          Player   @relation(fields: [playerId], references: [id])
  playerId        String
  game            Game     @relation(fields: [gameId], references: [id])
  gameId          String
  status          String   @default("active") // active | completed | failed | cashed-out
  currentQuestion Int      @default(1) // Question actuelle (1-15+)
  currentEarnings Float    @default(0) // Gains accumulés
  securedAmount   Float    @default(0) // Montant sécurisé au dernier palier
  // Nombre de sauts (skip) restants pour cette session
  skipsLeft       Int      @default(3)
  startedAt       DateTime @default(now())
  completedAt     DateTime?
  
  attempts        QuizAttempt[]
  
  @@index([playerId, gameId, status])
}

model QuizAttempt {
  id           String       @id @default(cuid())
  session      QuizSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId    String
  question     QuizQuestion @relation(fields: [questionId], references: [id])
  questionId   String
  questionNumber Int        // Position dans la session (1, 2, 3...)
  playerAnswer String?     // 'A', 'B', 'C', 'D' ou null si cash-out
  isCorrect    Boolean?    // null si cash-out
  prizeBefore  Float       // Gains avant cette question
  prizeAfter   Float       // Gains après cette question
  answeredAt   DateTime    @default(now())
  
  @@index([sessionId])
}

// Invitations / Parrainage
model ReferralInvite {
  id             String   @id @default(cuid())
  game           Game     @relation(fields: [gameId], references: [id])
  gameId         String
  inviter        Player   @relation("Inviter", fields: [inviterId], references: [id])
  inviterId      String
  code           String   @unique
  status         String   @default("pending") // pending | accepted | expired
  rewardAmount   Float    @default(1000000)
  acceptedBy     Player?  @relation("Invitee", fields: [acceptedById], references: [id])
  acceptedById   String?
  createdAt      DateTime @default(now())
  acceptedAt     DateTime?

  @@index([gameId, status])
}
